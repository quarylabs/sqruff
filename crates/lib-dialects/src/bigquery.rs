use itertools::Itertools;
use sqruff_lib_core::dialects::Dialect;
use sqruff_lib_core::dialects::init::DialectKind;
use sqruff_lib_core::dialects::syntax::SyntaxKind;
use sqruff_lib_core::helpers::{Config, ToMatchable};
use sqruff_lib_core::parser::grammar::anyof::{AnyNumberOf, one_of, optionally_bracketed};
use sqruff_lib_core::parser::grammar::delimited::Delimited;
use sqruff_lib_core::parser::grammar::sequence::{Bracketed, Sequence};
use sqruff_lib_core::parser::grammar::{Anything, Nothing, Ref};
use sqruff_lib_core::parser::lexer::Matcher;
use sqruff_lib_core::parser::matchable::MatchableTrait;
use sqruff_lib_core::parser::node_matcher::NodeMatcher;
use sqruff_lib_core::parser::parsers::{MultiStringParser, RegexParser, StringParser, TypedParser};
use sqruff_lib_core::parser::segments::generator::SegmentGenerator;
use sqruff_lib_core::parser::segments::meta::MetaSegment;
use sqruff_lib_core::parser::types::ParseMode;

use super::bigquery_keywords::{BIGQUERY_RESERVED_KEYWORDS, BIGQUERY_UNRESERVED_KEYWORDS};

pub fn dialect() -> Dialect {
    raw_dialect().config(|this| this.expand())
}

pub fn raw_dialect() -> Dialect {
    let ansi_dialect = super::ansi::raw_dialect();
    let mut bigquery_dialect = ansi_dialect.clone();
    bigquery_dialect.name = DialectKind::Bigquery;

    bigquery_dialect.insert_lexer_matchers(
        vec![
            Matcher::string("right_arrow", r#"=>"#, SyntaxKind::RightArrow),
            Matcher::string("question_mark", r#"?"#, SyntaxKind::QuestionMark),
            Matcher::regex(
                "at_sign_literal",
                r#"@[a-zA-Z_][\w]*"#,
                SyntaxKind::AtSignLiteral,
            ),
            Matcher::regex(
                "double_at_sign_literal",
                r#"@@[a-zA-Z_][\w\.]*"#,
                SyntaxKind::DoubleAtSignLiteral,
            ),
            Matcher::string("pipe_operator", r#"|>"#, SyntaxKind::PipeOperator),
        ],
        "equals",
    );

    bigquery_dialect.patch_lexer_matchers(vec![
        Matcher::legacy("single_quote", |_| true, r#"([rR]?[bB]?|[bB]?[rR]?)?('''((?<!\\)(\\{2})*\\'|'{,2}(?!')|[^'])*(?<!\\)(\\{2})*'''|'((?<!\\)(\\{2})*\\'|[^'])*(?<!\\)(\\{2})*')"#, SyntaxKind::SingleQuote),
        Matcher::legacy("double_quote", |_| true, r#"([rR]?[bB]?|[bB]?[rR]?)?(\"\"\"((?<!\\)(\\{2})*\\\"|\"{,2}(?!\")|[^\"])*(?<!\\)(\\{2})*\"\"\"|"((?<!\\)(\\{2})*\\"|[^"])*(?<!\\)(\\{2})*")"#, SyntaxKind::DoubleQuote),
    ]);

    bigquery_dialect.add([
        (
            "DoubleQuotedLiteralSegment".into(),
            TypedParser::new(SyntaxKind::DoubleQuote, SyntaxKind::QuotedLiteral)
                .to_matchable()
                .into(),
        ),
        (
            "SingleQuotedLiteralSegment".into(),
            TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::QuotedLiteral)
                .to_matchable()
                .into(),
        ),
        (
            "DoubleQuotedUDFBody".into(),
            TypedParser::new(SyntaxKind::DoubleQuote, SyntaxKind::UdfBody)
                .to_matchable()
                .into(),
        ),
        (
            "SingleQuotedUDFBody".into(),
            TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::UdfBody)
                .to_matchable()
                .into(),
        ),
        (
            "StartAngleBracketSegment".into(),
            StringParser::new("<", SyntaxKind::StartAngleBracket)
                .to_matchable()
                .into(),
        ),
        (
            "EndAngleBracketSegment".into(),
            StringParser::new(">", SyntaxKind::EndAngleBracket)
                .to_matchable()
                .into(),
        ),
        (
            "RightArrowSegment".into(),
            StringParser::new("=>", SyntaxKind::RightArrow)
                .to_matchable()
                .into(),
        ),
        (
            "DashSegment".into(),
            StringParser::new("-", SyntaxKind::Dash)
                .to_matchable()
                .into(),
        ),
        (
            "PipeOperatorSegment".into(),
            StringParser::new("|>", SyntaxKind::PipeOperator)
                .to_matchable()
                .into(),
        ),
        (
            "SelectClauseElementListGrammar".into(),
            Delimited::new(vec![Ref::new("SelectClauseElementSegment").to_matchable()])
                .config(|this| {
                    this.allow_trailing();
                })
                .to_matchable()
                .into(),
        ),
        (
            "QuestionMarkSegment".into(),
            StringParser::new("?", SyntaxKind::QuestionMark)
                .to_matchable()
                .into(),
        ),
        (
            "AtSignLiteralSegment".into(),
            TypedParser::new(SyntaxKind::AtSignLiteral, SyntaxKind::AtSignLiteral)
                .to_matchable()
                .into(),
        ),
        (
            "DoubleAtSignLiteralSegment".into(),
            TypedParser::new(
                SyntaxKind::DoubleAtSignLiteral,
                SyntaxKind::DoubleAtSignLiteral,
            )
            .to_matchable()
            .into(),
        ),
        (
            "NakedIdentifierFullSegment".into(),
            RegexParser::new(r#"[A-Z_][A-Z0-9_]*"#, SyntaxKind::NakedIdentifierAll)
                .to_matchable()
                .into(),
        ),
        (
            "NakedIdentifierPart".into(),
            RegexParser::new(r#"[A-Z0-9_]+"#, SyntaxKind::NakedIdentifier)
                .to_matchable()
                .into(),
        ),
        (
            "NakedCSIdentifierPart".into(),
            RegexParser::new(r#"[A-Z0-9_]+"#, SyntaxKind::NakedIdentifier)
                .to_matchable()
                .into(),
        ),
        (
            "NakedCSIdentifierSegment".into(),
            SegmentGenerator::new(|dialect| {
                let reserved_keywords = dialect.sets("reserved_keywords");
                let pattern = reserved_keywords.iter().join("|");
                let anti_template = format!("^({pattern})$");
                RegexParser::new(r#"[A-Z_][A-Z0-9_]*"#, SyntaxKind::NakedIdentifier)
                    .anti_template(&anti_template)
                    .to_matchable()
            })
            .into(),
        ),
        (
            "QuotedCSIdentifierSegment".into(),
            TypedParser::new(SyntaxKind::BackQuote, SyntaxKind::QuotedIdentifier)
                .to_matchable()
                .into(),
        ),
        (
            "SingleCSIdentifierGrammar".into(),
            one_of(vec![
                Ref::new("NakedCSIdentifierSegment").to_matchable(),
                Ref::new("QuotedCSIdentifierSegment").to_matchable(),
            ])
            .config(|this| {
                this.terminators = vec![Ref::new("DotSegment").to_matchable()];
            })
            .to_matchable()
            .into(),
        ),
        (
            "SingleIdentifierFullGrammar".into(),
            one_of(vec![
                Ref::new("NakedIdentifierSegment").to_matchable(),
                Ref::new("QuotedIdentifierSegment").to_matchable(),
                Ref::new("NakedIdentifierFullSegment").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "DefaultDeclareOptionsGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("DEFAULT").to_matchable(),
                one_of(vec![
                    Ref::new("LiteralGrammar").to_matchable(),
                    Bracketed::new(vec![Ref::new("SelectStatementSegment").to_matchable()])
                        .to_matchable(),
                    Ref::new("BareFunctionSegment").to_matchable(),
                    Ref::new("FunctionSegment").to_matchable(),
                    Ref::new("ArrayLiteralSegment").to_matchable(),
                    Ref::new("TupleSegment").to_matchable(),
                    Ref::new("BaseExpressionElementGrammar").to_matchable(),
                ])
                .config(|this| {
                    this.terminators = vec![Ref::new("SemicolonSegment").to_matchable()];
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ExtendedDatetimeUnitSegment".into(),
            SegmentGenerator::new(|dialect| {
                MultiStringParser::new(
                    dialect
                        .sets("extended_datetime_units")
                        .iter()
                        .map(|item| item.to_string())
                        .collect_vec(),
                    SyntaxKind::DatePart,
                )
                .to_matchable()
            })
            .into(),
        ),
        (
            "ProcedureNameIdentifierSegment".into(),
            one_of(vec![
                RegexParser::new(r#"[A-Z_][A-Z0-9_]*"#, SyntaxKind::ProcedureNameIdentifier)
                    .anti_template("STRUCT")
                    .to_matchable(),
                RegexParser::new(r#"`[^`]*`"#, SyntaxKind::ProcedureNameIdentifier).to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ProcedureParameterGrammar".into(),
            one_of(vec![
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("IN").to_matchable(),
                        Ref::keyword("OUT").to_matchable(),
                        Ref::keyword("INOUT").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("ParameterNameSegment").optional().to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("ANY").to_matchable(),
                            Ref::keyword("TYPE").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DatatypeSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
                one_of(vec![
                    Sequence::new(vec![
                        Ref::keyword("ANY").to_matchable(),
                        Ref::keyword("TYPE").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DatatypeSegment").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
    ]);

    bigquery_dialect.add([
        (
            "NakedIdentifierSegment".into(),
            SegmentGenerator::new(|dialect| {
                let reserved_keywords = dialect.sets("reserved_keywords");
                let pattern = reserved_keywords.iter().join("|");
                let anti_template = format!("^({pattern})$");
                RegexParser::new(r#"[A-Z_][A-Z0-9_]*"#, SyntaxKind::NakedIdentifier)
                    .anti_template(&anti_template)
                    .to_matchable()
            })
            .into(),
        ),
        (
            "DatatypeIdentifierSegment".into(),
            SegmentGenerator::new(|_| {
                MultiStringParser::new(
                    vec![
                        "INT64",
                        "INT",
                        "SMALLINT",
                        "INTEGER",
                        "BIGINT",
                        "TINYINT",
                        "BYTEINT",
                        "FLOAT64",
                        "NUMERIC",
                        "DECIMAL",
                        "BIGNUMERIC",
                        "BIGDECIMAL",
                        "BOOL",
                        "BOOLEAN",
                        "STRING",
                        "BYTES",
                        "DATE",
                        "DATETIME",
                        "TIME",
                        "TIMESTAMP",
                        "GEOGRAPHY",
                        "INTERVAL",
                        "JSON",
                        "RANGE",
                        "ARRAY",
                        "STRUCT",
                    ]
                    .into_iter()
                    .map(String::from)
                    .collect::<Vec<_>>(),
                    SyntaxKind::DataTypeIdentifier,
                )
                .to_matchable()
            })
            .into(),
        ),
    ]);

    bigquery_dialect.replace_grammar(
        "FunctionContentsExpressionGrammar",
        one_of(vec![
            Ref::new("DatetimeUnitSegment").to_matchable(),
            Ref::new("DatePartWeekSegment").to_matchable(),
            Sequence::new(vec![
                Ref::new("ExpressionSegment").to_matchable(),
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("IGNORE").to_matchable(),
                        Ref::keyword("RESPECT").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("NULLS").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::new("ExpressionSegment").to_matchable(),
                Ref::keyword("HAVING").to_matchable(),
                one_of(vec![
                    Ref::keyword("MIN").to_matchable(),
                    Ref::keyword("MAX").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable(),
            Ref::new("NamedArgumentSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "FunctionContentsGrammar",
        ansi_dialect.grammar("FunctionContentsGrammar").copy(
            Some(vec![
                Sequence::new(vec![
                    Ref::new("ExpressionSegment").to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    Ref::new("DatatypeSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("FORMAT").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("TimeZoneGrammar").optional().to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    bigquery_dialect.replace_grammar("TrimParametersGrammar", Nothing::new().to_matchable());

    bigquery_dialect.replace_grammar(
        "ParameterNameSegment",
        one_of(vec![
            RegexParser::new(r#"[A-Z_][A-Z0-9_]*"#, SyntaxKind::Parameter).to_matchable(),
            RegexParser::new(r#"`[^`]*`"#, SyntaxKind::Parameter).to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "DateTimeLiteralGrammar",
        Sequence::new(vec![
            one_of(vec![
                Ref::keyword("DATE").to_matchable(),
                Ref::keyword("DATETIME").to_matchable(),
                Ref::keyword("TIME").to_matchable(),
                Ref::keyword("TIMESTAMP").to_matchable(),
            ])
            .to_matchable(),
            TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::DateConstructorLiteral)
                .to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "JoinLikeClauseGrammar",
        Sequence::new(vec![
            AnyNumberOf::new(vec![
                Ref::new("FromPivotExpressionSegment").to_matchable(),
                Ref::new("FromUnpivotExpressionSegment").to_matchable(),
            ])
            .config(|this| {
                this.min_times(1);
            })
            .to_matchable(),
            Ref::new("AliasExpressionSegment").optional().to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "ConditionalCrossJoinKeywordsGrammar",
        Nothing::new().to_matchable(),
    );

    bigquery_dialect.replace_grammar("NaturalJoinKeywordsGrammar", Nothing::new().to_matchable());

    bigquery_dialect.replace_grammar(
        "UnconditionalCrossJoinKeywordsGrammar",
        Ref::keyword("CROSS").to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "MergeIntoLiteralGrammar",
        Sequence::new(vec![
            Ref::keyword("MERGE").to_matchable(),
            Ref::keyword("INTO").optional().to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "AccessorGrammar",
        AnyNumberOf::new(vec![
            Ref::new("ArrayAccessorSegment").to_matchable(),
            Ref::new("SemiStructuredAccessorSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "BracketedSetExpressionGrammar",
        Bracketed::new(vec![Ref::new("SetExpressionSegment").to_matchable()]).to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "NotEnforcedGrammar",
        Sequence::new(vec![
            Ref::keyword("NOT").to_matchable(),
            Ref::keyword("ENFORCED").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar("ReferenceMatchGrammar", Nothing::new().to_matchable());

    bigquery_dialect.replace_grammar(
        "SelectClauseTerminatorGrammar",
        one_of(vec![
            Ref::keyword("FROM").to_matchable(),
            Ref::keyword("WHERE").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Ref::keyword("OVERLAPS").to_matchable(),
            Ref::new("SetOperatorSegment").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
            Ref::new("PipeOperatorSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "FromClauseTerminatorGrammar",
        one_of(vec![
            Ref::keyword("WHERE").to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("GROUP").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("QUALIFY").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::new("SetOperatorSegment").to_matchable(),
            Ref::new("WithNoSchemaBindingClauseSegment").to_matchable(),
            Ref::new("WithDataClauseSegment").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
            Ref::keyword("OFFSET").to_matchable(),
            Ref::new("PipeOperatorSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "WhereClauseTerminatorGrammar",
        one_of(vec![
            Ref::keyword("LIMIT").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("GROUP").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("QUALIFY").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::keyword("OVERLAPS").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
            Ref::new("PipeOperatorSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "GroupByClauseTerminatorGrammar",
        one_of(vec![
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("QUALIFY").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
            Ref::new("PipeOperatorSegment").to_matchable(),
            Ref::keyword("ASC").to_matchable(),
            Ref::keyword("DESC").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "OrderByClauseTerminators",
        one_of(vec![
            Ref::keyword("LIMIT").to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("QUALIFY").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::new("FrameClauseUnitGrammar").to_matchable(),
            Ref::keyword("SEPARATOR").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
            Ref::new("PipeOperatorSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.sets_mut("unreserved_keywords").clear();

    bigquery_dialect.update_keywords_set_from_multiline_string(
        "unreserved_keywords",
        BIGQUERY_UNRESERVED_KEYWORDS,
    );

    bigquery_dialect.sets_mut("reserved_keywords").clear();

    bigquery_dialect
        .update_keywords_set_from_multiline_string("reserved_keywords", BIGQUERY_RESERVED_KEYWORDS);

    bigquery_dialect.sets_mut("datetime_units").extend([
        "MICROSECOND",
        "MILLISECOND",
        "SECOND",
        "MINUTE",
        "HOUR",
        "DAY",
        "DAYOFWEEK",
        "DAYOFYEAR",
        "WEEK",
        "ISOWEEK",
        "MONTH",
        "QUARTER",
        "YEAR",
        "ISOYEAR",
    ]);

    bigquery_dialect
        .sets_mut("extended_datetime_units")
        .extend(["DATE", "DATETIME", "TIME"]);

    bigquery_dialect.sets_mut("date_part_function_name").clear();

    bigquery_dialect
        .sets_mut("date_part_function_name")
        .extend([
            "DATE_DIFF",
            "DATE_TRUNC",
            "DATETIME_DIFF",
            "DATETIME_TRUNC",
            "EXTRACT",
            "LAST_DAY",
            "TIME_DIFF",
            "TIME_TRUNC",
            "TIMESTAMP_DIFF",
            "TIMESTAMP_TRUNC",
        ]);

    bigquery_dialect
        .sets_mut("value_table_functions")
        .extend(["UNNEST"]);

    bigquery_dialect.update_bracket_sets(
        "angle_bracket_pairs",
        vec![(
            "angle",
            "StartAngleBracketSegment",
            "EndAngleBracketSegment",
            false,
        )],
    );

    bigquery_dialect.add([
        (
            "ArrayTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::ArrayType, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ARRAY").to_matchable(),
                    Bracketed::new(vec![Ref::new("DatatypeSegment").to_matchable()])
                        .config(|this| {
                            this.optional();
                            this.bracket_type("angle");
                            this.bracket_pairs_set = "angle_bracket_pairs";
                        })
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ForSystemTimeAsOfSegment".into(),
            NodeMatcher::new(SyntaxKind::ForSystemTimeAsOfSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("FOR").to_matchable(),
                    one_of(vec![
                        Ref::keyword("SYSTEM_TIME").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SYSTEM").to_matchable(),
                            Ref::keyword("TIME").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    Ref::keyword("OF").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "QualifyClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::QualifyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("QUALIFY").to_matchable(),
                    MetaSegment::implicit_indent().to_matchable(),
                    optionally_bracketed(vec![Ref::new("ExpressionSegment").to_matchable()])
                        .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetOperatorSegment".into(),
            NodeMatcher::new(SyntaxKind::SetOperator, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::keyword("UNION").to_matchable(),
                        one_of(vec![
                            Ref::keyword("DISTINCT").to_matchable(),
                            Ref::keyword("ALL").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("INTERSECT").to_matchable(),
                        Ref::keyword("DISTINCT").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("EXCEPT").to_matchable(),
                        Ref::keyword("DISTINCT").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("INNER").to_matchable(),
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::keyword("FULL").to_matchable(),
                                    Ref::keyword("LEFT").to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::keyword("OUTER").optional().to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("OUTER").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("UNION").to_matchable(),
                                one_of(vec![
                                    Ref::keyword("ALL").to_matchable(),
                                    Ref::keyword("DISTINCT").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("INTERSECT").to_matchable(),
                                Ref::keyword("DISTINCT").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("EXCEPT").to_matchable(),
                                Ref::keyword("DISTINCT").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("BY").to_matchable(),
                                    Ref::keyword("NAME").to_matchable(),
                                    Sequence::new(vec![
                                        Ref::keyword("ON").to_matchable(),
                                        Ref::new("BracketedColumnReferenceListGrammar")
                                            .to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("STRICT").optional().to_matchable(),
                                    Ref::keyword("CORRESPONDING").to_matchable(),
                                    Sequence::new(vec![
                                        Ref::keyword("BY").to_matchable(),
                                        Ref::new("BracketedColumnReferenceListGrammar")
                                            .to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("SelectStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("QualifyClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    Some(Ref::new("OrderByClauseSegment").optional().to_matchable()),
                    None,
                    vec![Ref::new("PipeOperatorSegment").to_matchable()],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnorderedSelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("UnorderedSelectStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("QualifyClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    Some(Ref::new("OverlapsClauseSegment").optional().to_matchable()),
                    None,
                    vec![Ref::new("PipeOperatorSegment").to_matchable()],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "MultiStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::MultiStatementSegment, |_dialect| {
                one_of(vec![
                    Ref::new("ForInStatementSegment").to_matchable(),
                    Ref::new("RepeatStatementSegment").to_matchable(),
                    Ref::new("WhileStatementSegment").to_matchable(),
                    Ref::new("LoopStatementSegment").to_matchable(),
                    Ref::new("IfStatementSegment").to_matchable(),
                    Ref::new("CreateProcedureStatementSegment").to_matchable(),
                    Ref::new("BeginStatementSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FileSegment".into(),
            NodeMatcher::new(SyntaxKind::File, |_dialect| {
                Sequence::new(vec![
                    AnyNumberOf::new(vec![Ref::new("DelimiterGrammar").to_matchable()])
                        .to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::new("MultiStatementSegment").to_matchable(),
                            Ref::new("StatementSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("DelimiterGrammar").to_matchable(),
                        one_of(vec![
                            Ref::new("MultiStatementSegment").to_matchable(),
                            Ref::new("StatementSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    AnyNumberOf::new(vec![Ref::new("DelimiterGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StatementSegment".into(),
            NodeMatcher::new(SyntaxKind::Statement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("StatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("DeclareStatementSegment").to_matchable(),
                        Ref::new("SetStatementSegment").to_matchable(),
                        Ref::new("ExportStatementSegment").to_matchable(),
                        Ref::new("LoadDataStatementSegment").to_matchable(),
                        Ref::new("CreateExternalTableStatementSegment").to_matchable(),
                        Ref::new("CreateSnapshotTableStatementSegment").to_matchable(),
                        Ref::new("ExecuteImmediateSegment").to_matchable(),
                        Ref::new("AssertStatementSegment").to_matchable(),
                        Ref::new("CallStatementSegment").to_matchable(),
                        Ref::new("ReturnStatementSegment").to_matchable(),
                        Ref::new("BreakStatementSegment").to_matchable(),
                        Ref::new("LeaveStatementSegment").to_matchable(),
                        Ref::new("ContinueStatementSegment").to_matchable(),
                        Ref::new("RaiseStatementSegment").to_matchable(),
                        Ref::new("AlterViewStatementSegment").to_matchable(),
                        Ref::new("AlterSchemaStatementSegment").to_matchable(),
                        Ref::new("CreateMaterializedViewStatementSegment").to_matchable(),
                        Ref::new("CreateMaterializedViewAsReplicaOfStatementSegment")
                            .to_matchable(),
                        Ref::new("AlterMaterializedViewStatementSegment").to_matchable(),
                        Ref::new("DropMaterializedViewStatementSegment").to_matchable(),
                        Ref::new("DropProcedureStatementSegment").to_matchable(),
                        Ref::new("UndropSchemaStatementSegment").to_matchable(),
                        Ref::new("AlterOrganizationStatementSegment").to_matchable(),
                        Ref::new("AlterProjectStatementSegment").to_matchable(),
                        Ref::new("CreateSearchIndexStatementSegment").to_matchable(),
                        Ref::new("DropSearchIndexStatementSegment").to_matchable(),
                        Ref::new("CreateVectorIndexStatementSegment").to_matchable(),
                        Ref::new("DropVectorIndexStatementSegment").to_matchable(),
                        Ref::new("CreateRowAccessPolicyStatementSegment").to_matchable(),
                        Ref::new("DropRowAccessPolicyStatementSegment").to_matchable(),
                        Ref::new("AlterBiCapacityStatementSegment").to_matchable(),
                        Ref::new("CreateCapacityStatementSegment").to_matchable(),
                        Ref::new("AlterCapacityStatementSegment").to_matchable(),
                        Ref::new("DropCapacityStatementSegment").to_matchable(),
                        Ref::new("CreateReservationStatementSegment").to_matchable(),
                        Ref::new("AlterReservationStatementSegment").to_matchable(),
                        Ref::new("DropReservationStatementSegment").to_matchable(),
                        Ref::new("CreateAssignmentStatementSegment").to_matchable(),
                        Ref::new("DropAssignmentStatementSegment").to_matchable(),
                        Ref::new("DropTableFunctionStatementSegment").to_matchable(),
                        Ref::new("CreateTableFunctionStatementSegment").to_matchable(),
                        Ref::new("PipeStatementSegment").to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "AssertStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AssertStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ASSERT").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ForInStatementsSegment".into(),
            NodeMatcher::new(SyntaxKind::ForInStatements, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::new("StatementSegment").to_matchable(),
                            Ref::new("MultiStatementSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DelimiterGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.reset_terminators = true;
                    this.terminators = vec![
                        Sequence::new(vec![
                            Ref::keyword("END").to_matchable(),
                            Ref::keyword("FOR").to_matchable(),
                        ])
                        .to_matchable(),
                    ];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ForInStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ForInStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("FOR").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::keyword("IN").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("SelectableGrammar").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                    Ref::keyword("DO").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("ForInStatementsSegment").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                    Ref::keyword("END").to_matchable(),
                    Ref::keyword("FOR").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RepeatStatementsSegment".into(),
            NodeMatcher::new(SyntaxKind::RepeatStatements, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::new("StatementSegment").to_matchable(),
                            Ref::new("MultiStatementSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DelimiterGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.reset_terminators = true;
                    this.terminators = vec![Ref::keyword("UNTIL").to_matchable()];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RepeatStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::RepeatStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("REPEAT").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("RepeatStatementsSegment").to_matchable(),
                    Ref::keyword("UNTIL").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                    Ref::keyword("END").to_matchable(),
                    Ref::keyword("REPEAT").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IfStatementsSegment".into(),
            NodeMatcher::new(SyntaxKind::IfStatements, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::new("StatementSegment").to_matchable(),
                            Ref::new("MultiStatementSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DelimiterGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.reset_terminators = true;
                    this.terminators = vec![
                        Ref::keyword("ELSE").to_matchable(),
                        Ref::keyword("ELSEIF").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("END").to_matchable(),
                            Ref::keyword("IF").to_matchable(),
                        ])
                        .to_matchable(),
                    ];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IfStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::IfStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("IF").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                    Ref::keyword("THEN").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("IfStatementsSegment").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::keyword("ELSEIF").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                            Ref::keyword("THEN").to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            Ref::new("IfStatementsSegment").to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ELSE").to_matchable(),
                        MetaSegment::indent().to_matchable(),
                        Ref::new("IfStatementsSegment").to_matchable(),
                        MetaSegment::dedent().to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("END").to_matchable(),
                    Ref::keyword("IF").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LoopStatementsSegment".into(),
            NodeMatcher::new(SyntaxKind::LoopStatements, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::new("StatementSegment").to_matchable(),
                            Ref::new("MultiStatementSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DelimiterGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.reset_terminators = true;
                    this.terminators = vec![
                        Sequence::new(vec![
                            Ref::keyword("END").to_matchable(),
                            Ref::keyword("LOOP").to_matchable(),
                        ])
                        .to_matchable(),
                    ];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LoopStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::LoopStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("LOOP").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("LoopStatementsSegment").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                    Ref::keyword("END").to_matchable(),
                    Ref::keyword("LOOP").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WhileStatementsSegment".into(),
            NodeMatcher::new(SyntaxKind::WhileStatements, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        Ref::new("StatementSegment").to_matchable(),
                        Ref::new("DelimiterGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.reset_terminators = true;
                    this.terminators = vec![
                        Sequence::new(vec![
                            Ref::keyword("END").to_matchable(),
                            Ref::keyword("WHILE").to_matchable(),
                        ])
                        .to_matchable(),
                    ];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WhileStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::WhileStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("WHILE").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                    Ref::keyword("DO").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("WhileStatementsSegment").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                    Ref::keyword("END").to_matchable(),
                    Ref::keyword("WHILE").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectClauseModifierSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectClauseModifier, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("DISTINCT").to_matchable(),
                        Ref::keyword("ALL").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        one_of(vec![
                            Ref::keyword("STRUCT").to_matchable(),
                            Ref::keyword("VALUE").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IntervalExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::IntervalExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INTERVAL").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("DatetimeUnitSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::new("DatetimeUnitSegment").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("DatetimeUnitSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
    ]);

    bigquery_dialect.replace_grammar(
        "QuotedIdentifierSegment",
        TypedParser::new(SyntaxKind::BackQuote, SyntaxKind::QuotedIdentifier).to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "NumericLiteralSegment",
        one_of(vec![
            TypedParser::new(SyntaxKind::NumericLiteral, SyntaxKind::NumericLiteral).to_matchable(),
            Ref::new("ParameterizedSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "QuotedLiteralSegment",
        one_of(vec![
            Ref::new("SingleQuotedLiteralSegment").to_matchable(),
            Ref::new("DoubleQuotedLiteralSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "LiteralGrammar",
        ansi_dialect.grammar("LiteralGrammar").copy(
            Some(vec![
                Ref::new("ParameterizedSegment").to_matchable(),
                Ref::new("SystemVariableSegment").to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    bigquery_dialect.replace_grammar(
        "PostTableExpressionGrammar",
        Sequence::new(vec![
            Ref::new("ForSystemTimeAsOfSegment")
                .optional()
                .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("WITH").to_matchable(),
                Ref::keyword("OFFSET").to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("AS").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.replace_grammar(
        "FunctionNameIdentifierSegment",
        one_of(vec![
            RegexParser::new(r#"[A-Z_][A-Z0-9_]*"#, SyntaxKind::FunctionNameIdentifier)
                .anti_template("^(STRUCT|ARRAY)$")
                .to_matchable(),
            RegexParser::new(r#"`[^`]*`"#, SyntaxKind::FunctionNameIdentifier).to_matchable(),
        ])
        .to_matchable(),
    );

    bigquery_dialect.add([
        (
            "ExtractFunctionNameSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionName, |_dialect| {
                StringParser::new("EXTRACT", SyntaxKind::FunctionNameIdentifier).to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayFunctionNameSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionName, |_dialect| {
                StringParser::new("ARRAY", SyntaxKind::FunctionNameIdentifier).to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DatePartWeekSegment".into(),
            NodeMatcher::new(SyntaxKind::DatePartWeek, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("WEEK").to_matchable(),
                    Bracketed::new(vec![
                        one_of(vec![
                            Ref::keyword("SUNDAY").to_matchable(),
                            Ref::keyword("MONDAY").to_matchable(),
                            Ref::keyword("TUESDAY").to_matchable(),
                            Ref::keyword("WEDNESDAY").to_matchable(),
                            Ref::keyword("THURSDAY").to_matchable(),
                            Ref::keyword("FRIDAY").to_matchable(),
                            Ref::keyword("SATURDAY").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "NormalizeFunctionNameSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionName, |_dialect| {
                one_of(vec![
                    StringParser::new("NORMALIZE", SyntaxKind::FunctionNameIdentifier)
                        .to_matchable(),
                    StringParser::new("NORMALIZE_AND_CASEFOLD", SyntaxKind::FunctionNameIdentifier)
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FunctionNameSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionName, |_dialect| {
                Sequence::new(vec![
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("SAFE").to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("DotSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.terminators = vec![Ref::new("BracketedSegment").to_matchable()];
                    })
                    .to_matchable(),
                    one_of(vec![
                        Ref::new("FunctionNameIdentifierSegment").to_matchable(),
                        Ref::new("QuotedIdentifierSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.terminators = vec![Ref::new("BracketedSegment").to_matchable()];
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DateTimeFunctionContentsSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionContents, |_dialect| {
                Sequence::new(vec![
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Ref::new("DatetimeUnitSegment").to_matchable(),
                            Ref::new("DatePartWeekSegment").to_matchable(),
                            Ref::new("FunctionContentsGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ExtractFunctionContentsSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionContents, |_dialect| {
                Sequence::new(vec![
                    Bracketed::new(vec![
                        one_of(vec![
                            Ref::new("DatetimeUnitSegment").to_matchable(),
                            Ref::new("DatePartWeekSegment").to_matchable(),
                            Ref::new("ExtendedDatetimeUnitSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("FROM").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "NormalizeFunctionContentsSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionContents, |_dialect| {
                Sequence::new(vec![
                    Bracketed::new(vec![
                        Ref::new("ExpressionSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::new("CommaSegment").to_matchable(),
                            one_of(vec![
                                Ref::keyword("NFC").to_matchable(),
                                Ref::keyword("NFKC").to_matchable(),
                                Ref::keyword("NFD").to_matchable(),
                                Ref::keyword("NFKD").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FunctionSegment".into(),
            NodeMatcher::new(SyntaxKind::Function, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("ExtractFunctionNameSegment").to_matchable(),
                            Ref::new("ExtractFunctionContentsSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("NormalizeFunctionNameSegment").to_matchable(),
                            Ref::new("NormalizeFunctionContentsSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("DatePartFunctionNameSegment")
                                .exclude(Ref::new("ExtractFunctionNameSegment"))
                                .to_matchable(),
                            Ref::new("DateTimeFunctionContentsSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Sequence::new(vec![
                                Ref::new("FunctionNameSegment")
                                    .exclude(one_of(vec![
                                        Ref::new("DatePartFunctionNameSegment").to_matchable(),
                                        Ref::new("NormalizeFunctionNameSegment").to_matchable(),
                                        Ref::new("ValuesClauseSegment").to_matchable(),
                                    ]))
                                    .to_matchable(),
                                Ref::new("FunctionContentsSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("ArrayAccessorSegment").optional().to_matchable(),
                            Ref::new("SemiStructuredAccessorSegment")
                                .optional()
                                .to_matchable(),
                            Ref::new("PostFunctionGrammar").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.disallow_gaps();
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FunctionDefinitionGrammar".into(),
            NodeMatcher::new(SyntaxKind::FunctionDefinition, |_dialect| {
                Sequence::new(vec![
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("DETERMINISTIC").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("NOT").to_matchable(),
                                    Ref::keyword("DETERMINISTIC").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("LANGUAGE").to_matchable(),
                            Ref::new("NakedIdentifierSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("OPTIONS").to_matchable(),
                                Bracketed::new(vec![
                                    Delimited::new(vec![
                                        Sequence::new(vec![
                                            Ref::new("ParameterNameSegment").to_matchable(),
                                            Ref::new("EqualsSegment").to_matchable(),
                                            Anything::new().to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("AS").to_matchable(),
                            one_of(vec![
                                Ref::new("DoubleQuotedUDFBody").to_matchable(),
                                Ref::new("SingleQuotedUDFBody").to_matchable(),
                                Bracketed::new(vec![
                                    one_of(vec![
                                        Ref::new("ExpressionSegment").to_matchable(),
                                        Ref::new("SelectStatementSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("OptionsSegment").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WildcardExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::WildcardExpression, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("WildcardExpressionSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("ExceptClauseSegment").optional().to_matchable(),
                        Ref::new("ReplaceClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "ExceptClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectExceptClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("EXCEPT").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("SingleIdentifierGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TransactionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::TransactionStatement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("BEGIN").to_matchable(),
                        Ref::keyword("COMMIT").to_matchable(),
                        Ref::keyword("ROLLBACK").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("TRANSACTION").optional().to_matchable(),
                ])
                .config(|this| {
                    this.terminators = vec![Ref::new("DelimiterGrammar").to_matchable()];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "BeginStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::BeginStatement, |_dialect| {
                Sequence::new(vec![
                    Sequence::new(vec![
                        Ref::new("SingleIdentifierFullGrammar").to_matchable(),
                        Ref::new("ColonSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("BEGIN").to_matchable(),
                    Sequence::new(vec![
                        MetaSegment::indent().to_matchable(),
                        AnyNumberOf::new(vec![
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::new("StatementSegment").to_matchable(),
                                    Ref::new("MultiStatementSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("DelimiterGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.min_times(1);
                            this.reset_terminators = true;
                            this.terminators = vec![Ref::keyword("EXCEPTION").to_matchable()];
                        })
                        .to_matchable(),
                        MetaSegment::dedent().to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("EXCEPTION").to_matchable(),
                            Ref::keyword("WHEN").to_matchable(),
                            Ref::keyword("ERROR").to_matchable(),
                            Ref::keyword("THEN").to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            AnyNumberOf::new(vec![
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::new("StatementSegment").to_matchable(),
                                        Ref::new("MultiStatementSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::new("DelimiterGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.min_times(1);
                                this.reset_terminators = true;
                            })
                            .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("END").to_matchable(),
                    Ref::new("SingleIdentifierFullGrammar")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ReplaceClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectReplaceClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("REPLACE").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("BaseExpressionElementGrammar").to_matchable(),
                                Ref::keyword("AS").to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DatatypeSegment".into(),
            NodeMatcher::new(SyntaxKind::DataType, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::new("DatatypeIdentifierSegment").to_matchable(),
                        Ref::new("BracketedArguments").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ANY").to_matchable(),
                        Ref::keyword("TYPE").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("ArrayTypeSegment").to_matchable(),
                    Ref::new("StructTypeSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StructTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::DataType, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("STRUCT").to_matchable(),
                    Ref::new("StructTypeSchemaSegment")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StructTypeSchemaSegment".into(),
            NodeMatcher::new(SyntaxKind::StructTypeSchema, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::new("DatatypeSegment").to_matchable(),
                                Sequence::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            AnyNumberOf::new(vec![
                                Ref::new("ColumnConstraintSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("OptionsSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.bracket_type("angle");
                    this.bracket_pairs_set = "angle_bracket_pairs";
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayFunctionContentsSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionContents, |_dialect| {
                Sequence::new(vec![
                    Bracketed::new(vec![Ref::new("SelectableGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::ArrayExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::new("ArrayFunctionNameSegment").to_matchable(),
                    Ref::new("ArrayFunctionContentsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "NamedArgumentSegment".into(),
            NodeMatcher::new(SyntaxKind::NamedArgument, |_dialect| {
                Sequence::new(vec![
                    Ref::new("NakedIdentifierSegment").to_matchable(),
                    Ref::new("RightArrowSegment").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SemiStructuredAccessorSegment".into(),
            NodeMatcher::new(SyntaxKind::SemiStructuredExpression, |_dialect| {
                Sequence::new(vec![
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::new("DotSegment").to_matchable(),
                            one_of(vec![
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                Ref::new("StarSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ArrayAccessorSegment").optional().to_matchable(),
                    ])
                    .config(|this| {
                        this.min_times(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SplittableObjectReferenceGrammar".into(),
            NodeMatcher::new(SyntaxKind::ObjectReference, |_dialect| {
                let dialect = super::ansi::raw_dialect();
                dialect
                    .grammar("ObjectReferenceSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnReference, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Sequence::new(vec![
                        Ref::new("ObjectReferenceDelimiterGrammar").to_matchable(),
                        Delimited::new(vec![
                            Ref::new("SingleIdentifierFullGrammar").to_matchable(),
                        ])
                        .config(|this| {
                            this.disallow_gaps();
                            this.delimiter(Ref::new("ObjectReferenceDelimiterGrammar"));
                            this.terminators = vec![
                                Ref::keyword("ON").to_matchable(),
                                Ref::keyword("AS").to_matchable(),
                                Ref::keyword("USING").to_matchable(),
                                Ref::new("CommaSegment").to_matchable(),
                                Ref::new("CastOperatorSegment").to_matchable(),
                                Ref::new("StartSquareBracketSegment").to_matchable(),
                                Ref::new("StartBracketSegment").to_matchable(),
                                Ref::new("BinaryOperatorGrammar").to_matchable(),
                                Ref::new("ColonSegment").to_matchable(),
                                Ref::new("DelimiterGrammar").to_matchable(),
                                Ref::new("BracketedSegment").to_matchable(),
                            ];
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                        this.disallow_gaps();
                    })
                    .to_matchable(),
                ])
                .config(|this| {
                    this.disallow_gaps();
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::TableReference, |_dialect| {
                Delimited::new(vec![
                    Sequence::new(vec![
                        Ref::new("SingleCSIdentifierGrammar").to_matchable(),
                        AnyNumberOf::new(vec![
                            Sequence::new(vec![
                                Ref::new("DashSegment").to_matchable(),
                                Ref::new("NakedCSIdentifierPart").to_matchable(),
                            ])
                            .config(|this| {
                                this.disallow_gaps();
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.disallow_gaps();
                    })
                    .to_matchable(),
                ])
                .config(|this| {
                    this.disallow_gaps();
                    this.delimiter(Ref::new("ObjectReferenceDelimiterGrammar"));
                    this.terminators = vec![
                        Ref::keyword("ON").to_matchable(),
                        Ref::keyword("AS").to_matchable(),
                        Ref::keyword("USING").to_matchable(),
                        Ref::new("CommaSegment").to_matchable(),
                        Ref::new("CastOperatorSegment").to_matchable(),
                        Ref::new("StartSquareBracketSegment").to_matchable(),
                        Ref::new("StartBracketSegment").to_matchable(),
                        Ref::new("ColonSegment").to_matchable(),
                        Ref::new("DelimiterGrammar").to_matchable(),
                        Ref::new("JoinLikeClauseGrammar").to_matchable(),
                        Ref::new("BracketedSegment").to_matchable(),
                    ];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SystemVariableSegment".into(),
            NodeMatcher::new(SyntaxKind::SystemVariable, |_dialect| {
                Ref::new("DoubleAtSignLiteralSegment").to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DeclareStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DeclareSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DECLARE").to_matchable(),
                    Delimited::new(vec![Ref::new("SingleIdentifierFullGrammar").to_matchable()])
                        .to_matchable(),
                    one_of(vec![
                        Ref::new("DefaultDeclareOptionsGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::new("DatatypeSegment").to_matchable(),
                            Ref::new("DefaultDeclareOptionsGrammar")
                                .optional()
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SetSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SET").to_matchable(),
                    one_of(vec![
                        Ref::new("NakedIdentifierSegment").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("NakedIdentifierSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SystemVariableSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("EqualsSegment").to_matchable(),
                    Delimited::new(vec![
                        one_of(vec![
                            Ref::new("LiteralGrammar").to_matchable(),
                            Bracketed::new(vec![Ref::new("SelectStatementSegment").to_matchable()])
                                .to_matchable(),
                            Ref::new("BareFunctionSegment").to_matchable(),
                            Ref::new("FunctionSegment").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    one_of(vec![
                                        Ref::new("LiteralGrammar").to_matchable(),
                                        Bracketed::new(vec![
                                            Ref::new("SelectStatementSegment").to_matchable(),
                                        ])
                                        .to_matchable(),
                                        Ref::new("BareFunctionSegment").to_matchable(),
                                        Ref::new("FunctionSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("ArrayLiteralSegment").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ExecuteImmediateSegment".into(),
            NodeMatcher::new(SyntaxKind::ExecuteImmediate, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("EXECUTE").to_matchable(),
                    Ref::keyword("IMMEDIATE").to_matchable(),
                    optionally_bracketed(vec![
                        one_of(vec![
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Ref::new("SingleIdentifierFullGrammar").to_matchable(),
                            Ref::new("FunctionSegment").to_matchable(),
                            Ref::new("CaseExpressionSegment").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                            Bracketed::new(vec![Ref::new("SelectableGrammar").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("INTO").to_matchable(),
                        Delimited::new(vec![
                            Ref::new("SingleIdentifierFullGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("USING").to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("BaseExpressionElementGrammar").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("AS").to_matchable(),
                                    Ref::new("SingleIdentifierFullGrammar").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PartitionBySegment".into(),
            NodeMatcher::new(SyntaxKind::PartitionBySegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("PARTITION").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ClusterBySegment".into(),
            NodeMatcher::new(SyntaxKind::ClusterBySegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CLUSTER").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    Delimited::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DefaultCollateSegment".into(),
            NodeMatcher::new(SyntaxKind::DefaultCollate, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DEFAULT").to_matchable(),
                    Ref::keyword("COLLATE").to_matchable(),
                    Ref::new("LiteralGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "GrantToSegment".into(),
            NodeMatcher::new(SyntaxKind::GrantToSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("GRANT").to_matchable(),
                    Ref::keyword("TO").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("QuotedLiteralSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "OptionsSegment".into(),
            NodeMatcher::new(SyntaxKind::OptionsSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("OPTIONS").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("ParameterNameSegment").to_matchable(),
                                Ref::new("EqualsSegment").to_matchable(),
                                Ref::new("BaseExpressionElementGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableConstraintSegment".into(),
            NodeMatcher::new(SyntaxKind::TableConstraint, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::new("PrimaryKeyGrammar").to_matchable(),
                        Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                        Ref::keyword("NOT").to_matchable(),
                        Ref::keyword("ENFORCED").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::new("ForeignKeyGrammar").to_matchable(),
                        Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                        Ref::keyword("REFERENCES").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                        Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                        Ref::keyword("NOT").to_matchable(),
                        Ref::keyword("ENFORCED").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnDefinitionSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnDefinition, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::new("DatatypeSegment").to_matchable(),
                    AnyNumberOf::new(vec![Ref::new("ColumnConstraintSegment").to_matchable()])
                        .to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ViewColumnDefinitionSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnDefinition, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateSchemaStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateSchemaStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("SCHEMA").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("DefaultCollateSegment").optional().to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTableFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTableFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::keyword("FUNCTION").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Ref::new("ColumnDefinitionSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                                this.allow_trailing();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("RETURNS").to_matchable(),
                        Ref::keyword("TABLE").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.bracket_type("angle");
                            this.bracket_pairs_set = "angle_bracket_pairs";
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropTableFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropTableFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::keyword("FUNCTION").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Delimited::new(vec![Ref::new("TableReferenceSegment").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::new("TemporaryTransientGrammar")
                        .optional()
                        .to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("COPY").to_matchable(),
                            Ref::keyword("LIKE").to_matchable(),
                            Ref::keyword("CLONE").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                        Ref::new("ForSystemTimeAsOfSegment")
                            .optional()
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                one_of(vec![
                                    Ref::new("ColumnDefinitionSegment").to_matchable(),
                                    Ref::new("TableConstraintSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.allow_trailing();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("DefaultCollateSegment").optional().to_matchable(),
                    Ref::new("PartitionBySegment").optional().to_matchable(),
                    Ref::new("ClusterBySegment").optional().to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            one_of(vec![
                                Ref::new("OptionsSegment").to_matchable(),
                                Ref::new("DefaultCollateSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("ADD").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                                Ref::new("ColumnDefinitionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.allow_trailing();
                        })
                        .to_matchable(),
                        Delimited::new(vec![
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("ADD").to_matchable(),
                                    Sequence::new(vec![
                                        Ref::keyword("CONSTRAINT").to_matchable(),
                                        Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                    Ref::keyword("FOREIGN").to_matchable(),
                                    Ref::keyword("KEY").to_matchable(),
                                    Bracketed::new(vec![
                                        Delimited::new(vec![
                                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::keyword("REFERENCES").to_matchable(),
                                    Ref::new("TableReferenceSegment").to_matchable(),
                                    Bracketed::new(vec![
                                        Delimited::new(vec![
                                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::keyword("NOT").to_matchable(),
                                    Ref::keyword("ENFORCED").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("ADD").to_matchable(),
                                    Ref::keyword("PRIMARY").to_matchable(),
                                    Ref::keyword("KEY").to_matchable(),
                                    Bracketed::new(vec![
                                        Delimited::new(vec![
                                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::keyword("NOT").to_matchable(),
                                    Ref::keyword("ENFORCED").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.allow_trailing();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("RENAME").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::new("IfExistsGrammar").optional().to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                Ref::keyword("TO").to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.allow_trailing();
                        })
                        .to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("DROP").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::new("IfExistsGrammar").optional().to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("DROP").to_matchable(),
                                Ref::keyword("CONSTRAINT").to_matchable(),
                                Ref::new("IfExistsGrammar").optional().to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("DROP").to_matchable(),
                                Ref::keyword("PRIMARY").to_matchable(),
                                Ref::keyword("KEY").to_matchable(),
                                Ref::new("IfExistsGrammar").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("ALTER").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::new("IfExistsGrammar").optional().to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                one_of(vec![
                                    Sequence::new(vec![
                                        Ref::keyword("SET").to_matchable(),
                                        one_of(vec![
                                            Ref::new("OptionsSegment").to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("DATA").to_matchable(),
                                                Ref::keyword("TYPE").to_matchable(),
                                                Ref::new("DatatypeSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("DEFAULT").to_matchable(),
                                                one_of(vec![
                                                    Ref::new("LiteralGrammar").to_matchable(),
                                                    Ref::new("FunctionSegment").to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Sequence::new(vec![
                                        Ref::keyword("DROP").to_matchable(),
                                        one_of(vec![
                                            Ref::keyword("DEFAULT").to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("NOT").to_matchable(),
                                                Ref::keyword("NULL").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterSchemaStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterSchemaStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("SCHEMA").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            one_of(vec![
                                Ref::new("DefaultCollateSegment").to_matchable(),
                                Ref::new("OptionsSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ADD").to_matchable(),
                            Ref::keyword("REPLICA").to_matchable(),
                            Ref::new("BaseExpressionElementGrammar").to_matchable(),
                            Ref::new("OptionsSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            Ref::keyword("REPLICA").to_matchable(),
                            Ref::new("BaseExpressionElementGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateExternalTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateExternalTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("EXTERNAL").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("ColumnDefinitionSegment").to_matchable()])
                            .config(|this| {
                                this.allow_trailing();
                            })
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::keyword("WITH").to_matchable(),
                            Ref::keyword("CONNECTION").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("WITH").to_matchable(),
                            Ref::keyword("PARTITION").to_matchable(),
                            Ref::keyword("COLUMNS").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnDefinitionSegment").to_matchable(),
                                ])
                                .config(|this| {
                                    this.allow_trailing();
                                })
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::new("OptionsSegment").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateSnapshotTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateSnapshotTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("SNAPSHOT").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::keyword("CLONE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("ForSystemTimeAsOfSegment")
                        .optional()
                        .to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Ref::new("ViewColumnDefinitionSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("OptionsSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("ALTER").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::new("IfExistsGrammar").optional().to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                Ref::keyword("SET").to_matchable(),
                                Ref::new("OptionsSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateMaterializedViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateMaterializedViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("MATERIALIZED").to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("PartitionBySegment").optional().to_matchable(),
                    Ref::new("ClusterBySegment").optional().to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateMaterializedViewAsReplicaOfStatementSegment".into(),
            NodeMatcher::new(
                SyntaxKind::CreateMaterializedViewAsReplicaOfStatement,
                |_dialect| {
                    Sequence::new(vec![
                        Ref::keyword("CREATE").to_matchable(),
                        Ref::keyword("MATERIALIZED").to_matchable(),
                        Ref::keyword("VIEW").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                        Ref::new("OptionsSegment").optional().to_matchable(),
                        Ref::keyword("AS").to_matchable(),
                        Ref::keyword("REPLICA").to_matchable(),
                        Ref::keyword("OF").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                    ])
                    .to_matchable()
                },
            )
            .to_matchable()
            .into(),
        ),
        (
            "AlterMaterializedViewStatementSegment".into(),
            NodeMatcher::new(
                SyntaxKind::AlterMaterializedViewSetOptionsStatement,
                |_dialect| {
                    Sequence::new(vec![
                        Ref::keyword("ALTER").to_matchable(),
                        Ref::keyword("MATERIALIZED").to_matchable(),
                        Ref::keyword("VIEW").to_matchable(),
                        Ref::new("IfExistsGrammar").optional().to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                        Ref::keyword("SET").to_matchable(),
                        Ref::new("OptionsSegment").to_matchable(),
                    ])
                    .to_matchable()
                },
            )
            .to_matchable()
            .into(),
        ),
        (
            "DropTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    one_of(vec![
                        Ref::keyword("SNAPSHOT").to_matchable(),
                        Ref::keyword("EXTERNAL").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Delimited::new(vec![Ref::new("TableReferenceSegment").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Sequence::new(vec![Ref::keyword("TABLE").to_matchable()])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    Ref::keyword("FUNCTION").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropProcedureStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropProcedureStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("PROCEDURE").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("ProcedureNameSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UndropSchemaStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::UndropSchemaStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UNDROP").to_matchable(),
                    Ref::keyword("SCHEMA").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("SchemaReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropMaterializedViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropMaterializedViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("MATERIALIZED").to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ParameterizedSegment".into(),
            NodeMatcher::new(SyntaxKind::ParameterizedExpression, |_dialect| {
                one_of(vec![
                    Ref::new("AtSignLiteralSegment").to_matchable(),
                    Ref::new("QuestionMarkSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PivotForClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::PivotForClause, |_dialect| {
                Sequence::new(vec![
                    Ref::new("BaseExpressionElementGrammar").to_matchable(),
                ])
                .config(|this| {
                    this.parse_mode(ParseMode::Greedy);
                    this.terminators = vec![Ref::keyword("IN").to_matchable()];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromPivotExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::FromPivotExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("PIVOT").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("FunctionSegment").to_matchable(),
                                Ref::new("AliasExpressionSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("FOR").to_matchable(),
                        Ref::new("PivotForClauseSegment").to_matchable(),
                        Ref::keyword("IN").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("LiteralGrammar").to_matchable(),
                                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnpivotAliasExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::AliasExpression, |_dialect| {
                Sequence::new(vec![
                    MetaSegment::indent().to_matchable(),
                    Ref::new("AsAliasOperatorSegment").optional().to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("NumericLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromUnpivotExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::FromUnpivotExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UNPIVOT").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("INCLUDE").to_matchable(),
                            Ref::keyword("EXCLUDE").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("NULLS").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    one_of(vec![
                        Bracketed::new(vec![
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                            Ref::keyword("FOR").to_matchable(),
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                            Ref::keyword("IN").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Sequence::new(vec![
                                        Delimited::new(vec![
                                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                                        ])
                                        .to_matchable(),
                                        Ref::new("UnpivotAliasExpressionSegment")
                                            .optional()
                                            .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Bracketed::new(vec![
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("FOR").to_matchable(),
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                            Ref::keyword("IN").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Sequence::new(vec![
                                        Bracketed::new(vec![
                                            Delimited::new(vec![
                                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                        Ref::new("UnpivotAliasExpressionSegment")
                                            .optional()
                                            .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "InsertStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::InsertStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INSERT").to_matchable(),
                    Ref::keyword("INTO").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("BracketedColumnReferenceListGrammar")
                        .optional()
                        .to_matchable(),
                    Ref::new("SelectableGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SamplingExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::SampleExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("TABLESAMPLE").to_matchable(),
                    Ref::keyword("SYSTEM").to_matchable(),
                    Bracketed::new(vec![
                        Ref::new("NumericLiteralSegment").to_matchable(),
                        Ref::keyword("PERCENT").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MergeMatchSegment".into(),
            NodeMatcher::new(SyntaxKind::MergeMatch, |_dialect| {
                AnyNumberOf::new(vec![
                    Ref::new("MergeMatchedClauseSegment").to_matchable(),
                    Ref::new("MergeNotMatchedByTargetClauseSegment").to_matchable(),
                    Ref::new("MergeNotMatchedBySourceClauseSegment").to_matchable(),
                ])
                .config(|this| {
                    this.min_times(1);
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MergeNotMatchedByTargetClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::NotMatchedByTargetClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("WHEN").to_matchable(),
                    Ref::keyword("NOT").to_matchable(),
                    Ref::keyword("MATCHED").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("BY").to_matchable(),
                        Ref::keyword("TARGET").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AND").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("THEN").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("MergeInsertClauseSegment").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MergeNotMatchedBySourceClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::MergeWhenMatchedClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("WHEN").to_matchable(),
                    Ref::keyword("NOT").to_matchable(),
                    Ref::keyword("MATCHED").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    Ref::keyword("SOURCE").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AND").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("THEN").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Ref::new("MergeUpdateClauseSegment").to_matchable(),
                        Ref::new("MergeDeleteClauseSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MergeInsertClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::MergeInsertClause, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::keyword("INSERT").to_matchable(),
                        MetaSegment::indent().to_matchable(),
                        Ref::new("BracketedColumnReferenceListGrammar")
                            .optional()
                            .to_matchable(),
                        MetaSegment::dedent().to_matchable(),
                        Ref::new("ValuesClauseSegment").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("INSERT").to_matchable(),
                        Ref::keyword("ROW").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DeleteStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DeleteStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DELETE").to_matchable(),
                    Ref::keyword("FROM").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                    Ref::new("WhereClauseSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ExportStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ExportStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("EXPORT").to_matchable(),
                    Ref::keyword("DATA").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Ref::keyword("CONNECTION").to_matchable(),
                        Ref::new("ObjectReferenceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("OPTIONS").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Sequence::new(vec![
                                one_of(vec![
                                    StringParser::new("compression", SyntaxKind::ExportOption)
                                        .to_matchable(),
                                    StringParser::new("field_delimiter", SyntaxKind::ExportOption)
                                        .to_matchable(),
                                    StringParser::new("format", SyntaxKind::ExportOption)
                                        .to_matchable(),
                                    StringParser::new("header", SyntaxKind::ExportOption)
                                        .to_matchable(),
                                    StringParser::new("overwrite", SyntaxKind::ExportOption)
                                        .to_matchable(),
                                    StringParser::new("uri", SyntaxKind::ExportOption)
                                        .to_matchable(),
                                    StringParser::new(
                                        "use_avro_logical_types",
                                        SyntaxKind::ExportOption,
                                    )
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("EqualsSegment").to_matchable(),
                                Ref::new("BaseExpressionElementGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                one_of(vec![
                                    StringParser::new("header", SyntaxKind::ExportOption)
                                        .to_matchable(),
                                    StringParser::new("overwrite", SyntaxKind::ExportOption)
                                        .to_matchable(),
                                    StringParser::new(
                                        "use_avro_logical_types",
                                        SyntaxKind::ExportOption,
                                    )
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("EqualsSegment").to_matchable(),
                                one_of(vec![
                                    Ref::keyword("TRUE").to_matchable(),
                                    Ref::keyword("FALSE").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    Ref::new("SelectableGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LoadDataStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::LoadDataStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("LOAD").to_matchable(),
                    Ref::keyword("DATA").to_matchable(),
                    one_of(vec![
                        Ref::keyword("INTO").to_matchable(),
                        Ref::keyword("OVERWRITE").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::new("TemporaryGrammar").to_matchable(),
                        Ref::keyword("TABLE").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Ref::new("ColumnDefinitionSegment").to_matchable(),
                                Ref::new("TableConstraintSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.allow_trailing();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Sequence::new(vec![Ref::keyword("OVERWRITE").to_matchable()])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        Ref::keyword("PARTITIONS").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("EqualsSegment").to_matchable(),
                                    Ref::new("BaseExpressionElementGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("PartitionBySegment").optional().to_matchable(),
                    Ref::new("ClusterBySegment").optional().to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("FROM").to_matchable(),
                        Ref::keyword("FILES").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("EqualsSegment").to_matchable(),
                                    Ref::new("BaseExpressionElementGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Ref::keyword("PARTITION").to_matchable(),
                        Ref::keyword("COLUMNS").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.allow_trailing();
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Ref::keyword("CONNECTION").to_matchable(),
                        Ref::new("ObjectReferenceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ProcedureNameSegment".into(),
            NodeMatcher::new(SyntaxKind::ProcedureName, |_dialect| {
                Sequence::new(vec![
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                            Ref::new("DotSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Ref::new("ProcedureNameIdentifierSegment").to_matchable(),
                        Ref::new("QuotedIdentifierSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.disallow_gaps();
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ProcedureParameterListSegment".into(),
            NodeMatcher::new(SyntaxKind::ProcedureParameterList, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![Ref::new("ProcedureParameterGrammar").to_matchable()])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateProcedureStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateProcedureStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("PROCEDURE").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("ProcedureNameSegment").to_matchable(),
                    Ref::new("ProcedureParameterListSegment").to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                    Ref::new("BeginStatementSegment")
                        .reset_terminators()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CallStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CallStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CALL").to_matchable(),
                    Ref::new("ProcedureNameSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ReturnStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ReturnStatement, |_dialect| {
                Sequence::new(vec![Ref::keyword("RETURN").to_matchable()]).to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "BreakStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::BreakStatement, |_dialect| {
                Sequence::new(vec![Ref::keyword("BREAK").to_matchable()]).to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LeaveStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::LeaveStatement, |_dialect| {
                Sequence::new(vec![Ref::keyword("LEAVE").to_matchable()]).to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ContinueStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ContinueStatement, |_dialect| {
                one_of(vec![
                    Ref::keyword("CONTINUE").to_matchable(),
                    Ref::keyword("ITERATE").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RaiseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::RaiseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("RAISE").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("USING").to_matchable(),
                        Ref::keyword("MESSAGE").to_matchable(),
                        Ref::new("EqualsSegment").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterOrganizationStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterOrganizationStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("ORGANIZATION").to_matchable(),
                    Ref::keyword("SET").to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterProjectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterProjectStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("PROJECT").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::keyword("SET").to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateSearchIndexStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateSearchIndexStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("SEARCH").to_matchable(),
                    Ref::keyword("INDEX").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("IndexReferenceSegment").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("ALL").to_matchable(),
                                Ref::keyword("COLUMNS").to_matchable(),
                            ])
                            .to_matchable(),
                            Delimited::new(vec![
                                Ref::new("IndexColumnDefinitionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("OptionsSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropSearchIndexStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropSearchIndexStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("SEARCH").to_matchable(),
                    Ref::keyword("INDEX").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("IndexReferenceSegment").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateVectorIndexStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateVectorIndexStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("VECTOR").to_matchable(),
                    Ref::keyword("INDEX").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("IndexReferenceSegment").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Ref::new("IndexColumnDefinitionSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("StoringSegment").optional().to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StoringSegment".into(),
            NodeMatcher::new(SyntaxKind::StoringSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("STORING").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("SingleIdentifierGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropVectorIndexStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropVectorIndexStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("VECTOR").to_matchable(),
                    Ref::keyword("INDEX").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("IndexReferenceSegment").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateRowAccessPolicyStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateRowAccessPolicyStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("ROW").to_matchable(),
                    Ref::keyword("ACCESS").to_matchable(),
                    Ref::keyword("POLICY").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("NakedIdentifierSegment").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("GrantToSegment").optional().to_matchable(),
                    Ref::keyword("FILTER").to_matchable(),
                    Ref::keyword("USING").to_matchable(),
                    Bracketed::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropRowAccessPolicyStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropRowAccessPolicyStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("ROW").to_matchable(),
                    Ref::keyword("ACCESS").to_matchable(),
                    Ref::keyword("POLICY").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("NakedIdentifierSegment").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterBiCapacityStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterBiCapacityStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("BI_CAPACITY").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::keyword("SET").to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateCapacityStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateCapacityStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("CAPACITY").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterCapacityStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterCapacityStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("CAPACITY").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::keyword("SET").to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropCapacityStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropCapacityStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("CAPACITY").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateReservationStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateReservationStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("RESERVATION").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterReservationStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterReservationStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("RESERVATION").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::keyword("SET").to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropReservationStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropReservationStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("RESERVATION").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateAssignmentStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateAssignmentStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("ASSIGNMENT").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("OptionsSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropAssignmentStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropAssignmentStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("ASSIGNMENT").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PipeStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::PipeStatement, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::new("FromClauseSegment").to_matchable(),
                        AnyNumberOf::new(vec![
                            Ref::new("PipeOperatorClauseSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::new("SelectableGrammar").to_matchable(),
                        Ref::new("AliasExpressionSegment").optional().to_matchable(),
                        AnyNumberOf::new(vec![
                            Ref::new("PipeOperatorClauseSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.min_times(1);
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PipeOperatorClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::PipeOperatorClause, |_dialect| {
                Sequence::new(vec![
                    Ref::new("PipeOperatorSegment").to_matchable(),
                    one_of(vec![
                        Ref::new("SelectClauseSegment").to_matchable(),
                        Ref::new("ExtendClauseSegment").to_matchable(),
                        Ref::new("SetClauseListSegment").to_matchable(),
                        Ref::new("DropColumnClauseSegment").to_matchable(),
                        Ref::new("RenameColumnClauseSegment").to_matchable(),
                        Ref::new("AliasExpressionSegment").to_matchable(),
                        Ref::new("WhereClauseSegment").to_matchable(),
                        Ref::new("LimitClauseSegment").to_matchable(),
                        Ref::new("OrderByClauseSegment").to_matchable(),
                        Ref::new("AggregateClauseSegment").to_matchable(),
                        Ref::new("SetOperatorClauseSegment").to_matchable(),
                        Ref::new("JoinClauseSegment").to_matchable(),
                        Ref::new("CallOperatorSegment").to_matchable(),
                        Ref::new("SamplingExpressionSegment").to_matchable(),
                        Ref::new("PivotOperatorSegment").to_matchable(),
                        Ref::new("UnpivotOperatorSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ExtendClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::ExtendClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("EXTEND").to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("BaseExpressionElementGrammar").to_matchable(),
                            Ref::new("AliasExpressionSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropColumnClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::DropColumnClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RenameColumnClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::RenameColumnClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("RENAME").to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("AliasExpressionSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "GroupAndOrderByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::GroupAndOrderbyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("GROUP").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AND").to_matchable(),
                        Ref::keyword("ORDER").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Ref::keyword("ALL").to_matchable(),
                        Ref::new("GroupingSetsClauseSegment").to_matchable(),
                        Ref::new("CubeRollupClauseSegment").to_matchable(),
                        Sequence::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::new("ColumnReferenceSegment").to_matchable(),
                                        Ref::new("NumericLiteralSegment").to_matchable(),
                                        Ref::new("ExpressionSegment").to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.terminators = vec![
                                            Ref::new("GroupByClauseTerminatorGrammar")
                                                .to_matchable(),
                                        ];
                                    })
                                    .to_matchable(),
                                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                                    Sequence::new(vec![
                                        one_of(vec![
                                            Ref::keyword("ASC").to_matchable(),
                                            Ref::keyword("DESC").to_matchable(),
                                        ])
                                        .to_matchable(),
                                        Sequence::new(vec![
                                            Ref::keyword("NULLS").to_matchable(),
                                            one_of(vec![
                                                Ref::keyword("FIRST").to_matchable(),
                                                Ref::keyword("LAST").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .config(|this| {
                                            this.optional();
                                        })
                                        .to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AggregateClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::AggregateClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("AGGREGATE").to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("BaseExpressionElementGrammar").to_matchable(),
                            Ref::new("AliasExpressionSegment").optional().to_matchable(),
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::keyword("ASC").to_matchable(),
                                    Ref::keyword("DESC").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("NULLS").to_matchable(),
                                    one_of(vec![
                                        Ref::keyword("FIRST").to_matchable(),
                                        Ref::keyword("LAST").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("GroupAndOrderByClauseSegment")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetOperatorClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::SetOperatorClause, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SetOperatorSegment").to_matchable(),
                    Delimited::new(vec![Ref::new("NonSetSelectableGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CallOperatorSegment".into(),
            NodeMatcher::new(SyntaxKind::CallOperator, |_dialect| {
                Sequence::new(vec![
                    Ref::new("CallStatementSegment").to_matchable(),
                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PivotOperatorSegment".into(),
            NodeMatcher::new(SyntaxKind::PivotOperator, |_dialect| {
                Sequence::new(vec![
                    Ref::new("FromPivotExpressionSegment").to_matchable(),
                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnpivotOperatorSegment".into(),
            NodeMatcher::new(SyntaxKind::UnpivotOperator, |_dialect| {
                Sequence::new(vec![
                    Ref::new("FromUnpivotExpressionSegment").to_matchable(),
                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CTEDefinitionSegment".into(),
            NodeMatcher::new(SyntaxKind::CommonTableExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::new("CTEColumnList").optional().to_matchable(),
                    Ref::keyword("AS").optional().to_matchable(),
                    Bracketed::new(vec![
                        one_of(vec![
                            Ref::new("SelectableGrammar").to_matchable(),
                            Ref::new("PipeStatementSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.parse_mode(ParseMode::Greedy);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
    ]);

    bigquery_dialect
}
