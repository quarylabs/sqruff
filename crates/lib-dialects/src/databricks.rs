use sqruff_lib_core::dialects::Dialect;
use sqruff_lib_core::dialects::init::DialectKind;
use sqruff_lib_core::dialects::syntax::SyntaxKind;
use sqruff_lib_core::helpers::{Config, ToMatchable};
use sqruff_lib_core::parser::grammar::anyof::{AnyNumberOf, one_of, optionally_bracketed};
use sqruff_lib_core::parser::grammar::delimited::Delimited;
use sqruff_lib_core::parser::grammar::sequence::{Bracketed, Sequence};
use sqruff_lib_core::parser::grammar::{Anything, Ref};
use sqruff_lib_core::parser::lexer::Matcher;
use sqruff_lib_core::parser::matchable::MatchableTrait;
use sqruff_lib_core::parser::node_matcher::NodeMatcher;
use sqruff_lib_core::parser::parsers::{RegexParser, StringParser, TypedParser};
use sqruff_lib_core::parser::segments::meta::MetaSegment;

use super::databricks_keywords::{RESERVED_KEYWORDS, UNRESERVED_KEYWORDS};

pub fn dialect() -> Dialect {
    raw_dialect().config(|this| this.expand())
}

pub fn raw_dialect() -> Dialect {
    let sparksql_dialect = super::sparksql::raw_dialect();
    let mut databricks_dialect = sparksql_dialect.clone();
    databricks_dialect.name = DialectKind::Databricks;

    databricks_dialect
        .sets_mut("unreserved_keywords")
        .extend(UNRESERVED_KEYWORDS);

    databricks_dialect
        .sets_mut("unreserved_keywords")
        .extend(sparksql_dialect.sets("reserved_keywords"));

    databricks_dialect
        .sets_mut("unreserved_keywords")
        .retain(|item| !RESERVED_KEYWORDS.contains(item));

    databricks_dialect.sets_mut("reserved_keywords").clear();

    databricks_dialect
        .sets_mut("reserved_keywords")
        .extend(RESERVED_KEYWORDS);

    databricks_dialect
        .sets_mut("date_part_function_name")
        .extend(["TIMEDIFF"]);

    databricks_dialect.insert_lexer_matchers(
        vec![Matcher::string(
            "right_arrow",
            r#"=>"#,
            SyntaxKind::RightArrow,
        )],
        "equals",
    );

    databricks_dialect.insert_lexer_matchers(
        vec![Matcher::regex(
            "command",
            r#"(\r?\n){2}-- COMMAND ----------(\r?\n)"#,
            SyntaxKind::Command,
        )],
        "newline",
    );

    databricks_dialect.insert_lexer_matchers(
        vec![
            Matcher::regex(
                "notebook_start",
                r#"-- Databricks notebook source(\r?\n){1}"#,
                SyntaxKind::NotebookStart,
            ),
            Matcher::regex(
                "magic_single_line",
                r#"(-- MAGIC %)([^\n]{2,})( [^%]{1})([^\n]*)"#,
                SyntaxKind::MagicSingleLine,
            ),
            Matcher::regex(
                "magic_line",
                r#"(-- MAGIC)( [^%]{1})([^\n]*)"#,
                SyntaxKind::MagicLine,
            ),
            Matcher::regex(
                "magic_start",
                r#"(-- MAGIC %)([^\n]{2,})(\r?\n)"#,
                SyntaxKind::MagicStart,
            ),
        ],
        "inline_comment",
    );

    databricks_dialect.add([
        (
            "CommandCellSegment".into(),
            TypedParser::new(SyntaxKind::Command, SyntaxKind::StatementTerminator)
                .to_matchable()
                .into(),
        ),
        (
            "DoubleQuotedUDFBody".into(),
            TypedParser::new(SyntaxKind::DoubleQuote, SyntaxKind::UdfBody)
                .to_matchable()
                .into(),
        ),
        (
            "SingleQuotedUDFBody".into(),
            TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::UdfBody)
                .to_matchable()
                .into(),
        ),
        (
            "DollarQuotedUDFBody".into(),
            TypedParser::new(SyntaxKind::DollarQuote, SyntaxKind::UdfBody)
                .to_matchable()
                .into(),
        ),
        (
            "RightArrowSegment".into(),
            StringParser::new("=>", SyntaxKind::RightArrow)
                .to_matchable()
                .into(),
        ),
        (
            "PrincipalIdentifierSegment".into(),
            one_of(vec![
                Ref::new("NakedIdentifierSegment").to_matchable(),
                Ref::new("BackQuotedIdentifierSegment").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "PredictiveOptimizationGrammar".into(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("ENABLE").to_matchable(),
                    Ref::keyword("DISABLE").to_matchable(),
                    Ref::keyword("INHERIT").to_matchable(),
                ])
                .to_matchable(),
                Ref::keyword("PREDICTIVE").to_matchable(),
                Ref::keyword("OPTIMIZATION").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "SetOwnerGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("SET").optional().to_matchable(),
                Ref::keyword("OWNER").to_matchable(),
                Ref::keyword("TO").to_matchable(),
                Ref::new("PrincipalIdentifierSegment").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "SetTagOnGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("SET").to_matchable(),
                Ref::keyword("TAG").to_matchable(),
                Ref::keyword("ON").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "UnsetTagOnGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("UNSET").to_matchable(),
                Ref::keyword("TAG").to_matchable(),
                Ref::keyword("ON").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "SetTagsGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("SET").to_matchable(),
                Ref::keyword("TAGS").to_matchable(),
                Ref::new("BracketedPropertyListGrammar").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "UnsetTagsGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("UNSET").to_matchable(),
                Ref::keyword("TAGS").to_matchable(),
                Ref::new("BracketedPropertyNameListGrammar").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ColumnDefaultGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("DEFAULT").to_matchable(),
                one_of(vec![
                    Ref::new("LiteralGrammar").to_matchable(),
                    Ref::new("FunctionSegment").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ConstraintOptionGrammar".into(),
            Sequence::new(vec![
                Sequence::new(vec![
                    Ref::keyword("ENABLE").to_matchable(),
                    Ref::keyword("NOVALIDATE").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("NOT").to_matchable(),
                    Ref::keyword("ENFORCED").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![Ref::keyword("DEFERRABLE").to_matchable()])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("INITIALLY").to_matchable(),
                    Ref::keyword("DEFERRED").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                one_of(vec![
                    Ref::keyword("NORELY").to_matchable(),
                    Ref::keyword("RELY").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ForeignKeyOptionGrammar".into(),
            Sequence::new(vec![
                Sequence::new(vec![
                    Ref::keyword("MATCH").to_matchable(),
                    Ref::keyword("FULL").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("ON").to_matchable(),
                    Ref::keyword("UPDATE").to_matchable(),
                    Ref::keyword("NO").to_matchable(),
                    Ref::keyword("ACTION").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("ON").to_matchable(),
                    Ref::keyword("DELETE").to_matchable(),
                    Ref::keyword("NO").to_matchable(),
                    Ref::keyword("ACTION").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "DropConstraintGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("DROP").to_matchable(),
                one_of(vec![
                    Sequence::new(vec![
                        Ref::new("PrimaryKeyGrammar").to_matchable(),
                        Ref::new("IfExistsGrammar").optional().to_matchable(),
                        one_of(vec![
                            Ref::keyword("RESTRICT").to_matchable(),
                            Ref::keyword("CASCADE").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::new("ForeignKeyGrammar").to_matchable(),
                        Ref::new("IfExistsGrammar").optional().to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("CONSTRAINT").to_matchable(),
                        Ref::new("IfExistsGrammar").optional().to_matchable(),
                        Ref::new("ObjectReferenceSegment").to_matchable(),
                        one_of(vec![
                            Ref::keyword("RESTRICT").to_matchable(),
                            Ref::keyword("CASCADE").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "AlterPartitionGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("PARTITION").to_matchable(),
                Bracketed::new(vec![
                    Delimited::new(vec![
                        AnyNumberOf::new(vec![
                            one_of(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("SetClauseSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.min_times(1);
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "RowFilterClauseGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("ROW").to_matchable(),
                Ref::keyword("FILTER").to_matchable(),
                Ref::new("ObjectReferenceSegment").to_matchable(),
                Ref::keyword("ON").to_matchable(),
                Bracketed::new(vec![
                    Delimited::new(vec![
                        one_of(vec![
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("LiteralGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "PropertiesBackTickedIdentifierSegment".into(),
            RegexParser::new(r#"`.+`"#, SyntaxKind::PropertiesNakedIdentifier)
                .to_matchable()
                .into(),
        ),
        (
            "LocationWithCredentialGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("LOCATION").to_matchable(),
                Ref::new("QuotedLiteralSegment").to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("WITH").to_matchable(),
                    Bracketed::new(vec![
                        Ref::keyword("CREDENTIAL").to_matchable(),
                        Ref::new("PrincipalIdentifierSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "NotebookStart".into(),
            TypedParser::new(SyntaxKind::NotebookStart, SyntaxKind::NotebookStart)
                .to_matchable()
                .into(),
        ),
        (
            "MagicSingleLineGrammar".into(),
            TypedParser::new(SyntaxKind::MagicSingleLine, SyntaxKind::MagicSingleLine)
                .to_matchable()
                .into(),
        ),
        (
            "MagicLineGrammar".into(),
            TypedParser::new(SyntaxKind::MagicLine, SyntaxKind::MagicLine)
                .to_matchable()
                .into(),
        ),
        (
            "MagicStartGrammar".into(),
            TypedParser::new(SyntaxKind::MagicStart, SyntaxKind::MagicStart)
                .to_matchable()
                .into(),
        ),
        (
            "VariableNameIdentifierSegment".into(),
            one_of(vec![
                Ref::new("NakedIdentifierSegment").to_matchable(),
                Ref::new("BackQuotedIdentifierSegment").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
    ]);

    databricks_dialect.replace_grammar(
        "DelimiterGrammar",
        one_of(vec![
            Ref::new("SemicolonSegment").to_matchable(),
            Ref::new("CommandCellSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "DescribeObjectGrammar",
        sparksql_dialect.grammar("DescribeObjectGrammar").copy(
            Some(vec![
                Sequence::new(vec![
                    Ref::keyword("VOLUME").to_matchable(),
                    Ref::new("VolumeReferenceSegment").to_matchable(),
                ])
                .to_matchable(),
            ]),
            Some(0),
            None,
            None,
            vec![],
            false,
        ),
    );

    databricks_dialect.replace_grammar(
        "FunctionContentsExpressionGrammar",
        one_of(vec![
            Ref::new("ExpressionSegment").to_matchable(),
            Ref::new("NamedArgumentSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "PropertiesNakedIdentifierSegment",
        RegexParser::new(r#"[A-Z_][A-Z0-9_]*"#, SyntaxKind::PropertiesNakedIdentifier)
            .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "ShowDatabasesSchemasGrammar",
        Sequence::new(vec![
            one_of(vec![
                Ref::keyword("DATABASES").to_matchable(),
                Ref::keyword("SCHEMAS").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("FROM").to_matchable(),
                    Ref::keyword("IN").to_matchable(),
                ])
                .to_matchable(),
                Ref::new("DatabaseReferenceSegment").to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("LIKE").optional().to_matchable(),
                Ref::new("QuotedLiteralSegment").to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "ShowFunctionsGrammar",
        Sequence::new(vec![
            one_of(vec![
                Ref::keyword("USER").to_matchable(),
                Ref::keyword("SYSTEM").to_matchable(),
                Ref::keyword("ALL").to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
            Ref::keyword("FUNCTIONS").to_matchable(),
            Sequence::new(vec![
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("FROM").to_matchable(),
                        Ref::keyword("IN").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("LIKE").optional().to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("DatabaseReferenceSegment").to_matchable(),
                            Ref::new("DotSegment").to_matchable(),
                            Ref::new("FunctionNameSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.disallow_gaps();
                        })
                        .to_matchable(),
                        Ref::new("FunctionNameSegment").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "ShowTablesGrammar",
        Sequence::new(vec![
            Ref::keyword("TABLES").to_matchable(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("FROM").to_matchable(),
                    Ref::keyword("IN").to_matchable(),
                ])
                .to_matchable(),
                Ref::new("DatabaseReferenceSegment").to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("LIKE").optional().to_matchable(),
                Ref::new("QuotedLiteralSegment").to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "ShowViewsGrammar",
        Sequence::new(vec![
            Ref::keyword("VIEWS").to_matchable(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("FROM").to_matchable(),
                    Ref::keyword("IN").to_matchable(),
                ])
                .to_matchable(),
                Ref::new("DatabaseReferenceSegment").to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("LIKE").optional().to_matchable(),
                Ref::new("QuotedLiteralSegment").to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "ShowObjectGrammar",
        sparksql_dialect.grammar("ShowObjectGrammar").copy(
            Some(vec![
                Sequence::new(vec![
                    Ref::keyword("VOLUMES").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("FROM").to_matchable(),
                            Ref::keyword("IN").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DatabaseReferenceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("LIKE").optional().to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    databricks_dialect.replace_grammar(
        "NotNullGrammar",
        Sequence::new(vec![
            Ref::keyword("NOT").to_matchable(),
            Ref::keyword("NULL").to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "FunctionNameIdentifierSegment",
        one_of(vec![
            TypedParser::new(SyntaxKind::Word, SyntaxKind::FunctionNameIdentifier).to_matchable(),
            Ref::new("BackQuotedIdentifierSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "PreTableFunctionKeywordsGrammar",
        one_of(vec![Ref::keyword("STREAM").to_matchable()]).to_matchable(),
    );

    databricks_dialect.replace_grammar(
        "ColumnGeneratedGrammar",
        one_of(vec![
            Sequence::new(vec![
                Ref::keyword("GENERATED").to_matchable(),
                Ref::keyword("ALWAYS").to_matchable(),
                Ref::keyword("AS").to_matchable(),
                Bracketed::new(vec![
                    one_of(vec![
                        Ref::new("FunctionSegment").to_matchable(),
                        Ref::new("BareFunctionSegment").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("GENERATED").to_matchable(),
                one_of(vec![
                    Ref::keyword("ALWAYS").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("BY").to_matchable(),
                        Ref::keyword("DEFAULT").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
                Ref::keyword("AS").to_matchable(),
                Ref::keyword("IDENTITY").to_matchable(),
                Bracketed::new(vec![
                    Sequence::new(vec![
                        Sequence::new(vec![
                            Ref::keyword("START").to_matchable(),
                            Ref::keyword("WITH").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("INCREMENT").to_matchable(),
                            Ref::keyword("BY").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable(),
        ])
        .to_matchable(),
    );

    databricks_dialect.add([
        (
            "IdentifierClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::IdentifierClauseSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("IDENTIFIER").to_matchable(),
                    Bracketed::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ObjectReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::ObjectReference, |_dialect| {
                Delimited::new(vec![
                    one_of(vec![
                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                        Ref::new("IdentifierClauseSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.disallow_gaps();
                    this.delimiter(Ref::new("ObjectReferenceDelimiterGrammar"));
                    this.terminators =
                        vec![Ref::new("ObjectReferenceTerminatorGrammar").to_matchable()];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DatabaseReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::DatabaseReference, |_dialect| {
                _dialect
                    .grammar("ObjectReferenceSegment")
                    .match_grammar(&_dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::TableReference, |_dialect| {
                _dialect
                    .grammar("ObjectReferenceSegment")
                    .match_grammar(&_dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SchemaReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::SchemaReference, |_dialect| {
                _dialect
                    .grammar("ObjectReferenceSegment")
                    .match_grammar(&_dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::TableExpression, |_dialect| {
                {
                    let dialect = super::sparksql::raw_dialect();
                    dialect
                        .grammar("TableExpressionSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![Ref::new("IdentifierClauseSegment").to_matchable()]),
                    None,
                    Some(Ref::new("ValuesClauseSegment").to_matchable()),
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "CatalogReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::CatalogReference, |_dialect| {
                let dialect = super::ansi::raw_dialect();
                dialect
                    .grammar("ObjectReferenceSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "VolumeReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::VolumeReference, |_dialect| {
                let dialect = super::ansi::raw_dialect();
                dialect
                    .grammar("ObjectReferenceSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterCatalogStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterCatalogStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("CATALOG").to_matchable(),
                    Ref::new("CatalogReferenceSegment").to_matchable(),
                    one_of(vec![
                        Ref::new("SetOwnerGrammar").to_matchable(),
                        Ref::new("SetTagsGrammar").to_matchable(),
                        Ref::new("UnsetTagsGrammar").to_matchable(),
                        Ref::new("PredictiveOptimizationGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateCatalogStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateCatalogStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("CATALOG").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("CatalogReferenceSegment").to_matchable(),
                    Ref::new("CommentGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropCatalogStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropCatalogStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("CATALOG").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("CatalogReferenceSegment").to_matchable(),
                    Ref::new("DropBehaviorGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UseCatalogStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::UseCatalogStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("USE").to_matchable(),
                    Ref::keyword("CATALOG").to_matchable(),
                    Ref::new("CatalogReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UseDatabaseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::UseDatabaseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("USE").to_matchable(),
                    one_of(vec![
                        Ref::keyword("DATABASE").to_matchable(),
                        Ref::keyword("SCHEMA").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterDatabaseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterDatabaseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    one_of(vec![
                        Ref::keyword("DATABASE").to_matchable(),
                        Ref::keyword("SCHEMA").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("DatabasePropertiesGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SetOwnerGrammar").to_matchable(),
                        Ref::new("SetTagsGrammar").to_matchable(),
                        Ref::new("UnsetTagsGrammar").to_matchable(),
                        Ref::new("PredictiveOptimizationGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterVolumeStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterVolumeStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("VOLUME").to_matchable(),
                    Ref::new("VolumeReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("VolumeReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SetOwnerGrammar").to_matchable(),
                        Ref::new("SetTagsGrammar").to_matchable(),
                        Ref::new("UnsetTagsGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateVolumeStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateVolumeStatement, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::keyword("CREATE").to_matchable(),
                        Ref::keyword("VOLUME").to_matchable(),
                        Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                        Ref::new("VolumeReferenceSegment").to_matchable(),
                        Ref::new("CommentGrammar").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("CREATE").to_matchable(),
                        Ref::keyword("EXTERNAL").to_matchable(),
                        Ref::keyword("VOLUME").to_matchable(),
                        Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                        Ref::new("VolumeReferenceSegment").to_matchable(),
                        Ref::new("LocationGrammar").to_matchable(),
                        Ref::new("CommentGrammar").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropVolumeStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropVolumeStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("VOLUME").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("VolumeReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateDatabaseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateDatabaseStatement, |_dialect| {
                {
                    let dialect = super::sparksql::raw_dialect();
                    dialect
                        .grammar("CreateDatabaseStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Sequence::new(vec![
                            Ref::keyword("MANAGED").optional().to_matchable(),
                            Ref::keyword("LOCATION").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ]),
                    Some(5),
                    None,
                    Some(vec![Ref::new("LocationGrammar").optional().to_matchable()]),
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateViewStatement, |_dialect| {
                {
                    let dialect = super::sparksql::raw_dialect();
                    dialect
                        .grammar("CreateViewStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Sequence::new(vec![
                            Ref::keyword("PRIVATE").optional().to_matchable(),
                            Ref::keyword("MATERIALIZED").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ]),
                    None,
                    Some(Ref::keyword("MATERIALIZED").optional().to_matchable()),
                    Some(vec![Ref::keyword("MATERIALIZED").optional().to_matchable()]),
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "MaskStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::MaskStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("MASK").to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("USING").to_matchable(),
                        Ref::keyword("COLUMNS").to_matchable(),
                        Bracketed::new(vec![
                            AnyNumberOf::new(vec![
                                one_of(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                    Ref::new("ExpressionSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnFieldDefinitionSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnDefinition, |_dialect| {
                Sequence::new(vec![
                    Ref::new("ColumnReferenceSegment").to_matchable(),
                    Ref::new("DatatypeSegment").to_matchable(),
                    Bracketed::new(vec![Anything::new().to_matchable()])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("ColumnPropertiesSegment").to_matchable(),
                        Ref::new("ColumnConstraintSegment").to_matchable(),
                        Ref::new("ColumnDefaultGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PropertyNameSegment".into(),
            NodeMatcher::new(SyntaxKind::PropertyNameIdentifier, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Delimited::new(vec![
                            one_of(vec![
                                Ref::new("PropertiesNakedIdentifierSegment").to_matchable(),
                                Ref::new("PropertiesBackTickedIdentifierSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.disallow_gaps();
                            this.delimiter(Ref::new("DotSegment"));
                        })
                        .to_matchable(),
                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableConstraintSegment".into(),
            NodeMatcher::new(SyntaxKind::TableConstraint, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CONSTRAINT").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("ObjectReferenceSegment").optional().to_matchable(),
                            Ref::new("PrimaryKeyGrammar").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                    Ref::keyword("TIMESERIES").optional().to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("ConstraintOptionGrammar")
                                .optional()
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("ObjectReferenceSegment").optional().to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            Ref::new("ForeignKeyGrammar").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("REFERENCES").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                            Ref::new("BracketedColumnReferenceListGrammar")
                                .optional()
                                .to_matchable(),
                            one_of(vec![
                                Ref::new("ForeignKeyOptionGrammar").to_matchable(),
                                Ref::new("ConstraintOptionGrammar").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("ObjectReferenceSegment").to_matchable(),
                            Ref::keyword("CHECK").to_matchable(),
                            Bracketed::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                                .to_matchable(),
                            Ref::keyword("ENFORCED").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnsetTagStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::TagStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::new("UnsetTagOnGrammar").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("CATALOG").to_matchable(),
                            Ref::new("CatalogReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("DATABASE").to_matchable(),
                                Ref::keyword("SCHEMA").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("DatabaseReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("TABLE").to_matchable(),
                                Ref::keyword("VIEW").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("VOLUME").to_matchable(),
                            Ref::new("VolumeReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Ref::new("BackQuotedIdentifierSegment").to_matchable(),
                        Ref::new("NakedIdentifierSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TagStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::TagStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SetTagOnGrammar").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("CATALOG").to_matchable(),
                            Ref::new("CatalogReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("DATABASE").to_matchable(),
                                Ref::keyword("SCHEMA").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("DatabaseReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("TABLE").to_matchable(),
                                Ref::keyword("VIEW").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("VOLUME").to_matchable(),
                            Ref::new("VolumeReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Ref::new("BackQuotedIdentifierSegment").to_matchable(),
                        Ref::new("NakedIdentifierSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("EqualsSegment").to_matchable(),
                    one_of(vec![
                        Ref::new("BackQuotedIdentifierSegment").to_matchable(),
                        Ref::new("NakedIdentifierSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ADD").to_matchable(),
                            one_of(vec![
                                Ref::keyword("COLUMNS").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                            ])
                            .to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            optionally_bracketed(vec![
                                Delimited::new(vec![
                                    Sequence::new(vec![
                                        Ref::new("ColumnFieldDefinitionSegment").to_matchable(),
                                        Ref::new("ColumnDefaultGrammar").optional().to_matchable(),
                                        Ref::new("CommentGrammar").optional().to_matchable(),
                                        Ref::new("FirstOrAfterGrammar").optional().to_matchable(),
                                        Ref::new("MaskStatementSegment").optional().to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("ALTER").to_matchable(),
                                Ref::keyword("CHANGE").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("COLUMN").optional().to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            one_of(vec![
                                Ref::new("CommentGrammar").to_matchable(),
                                Ref::new("FirstOrAfterGrammar").to_matchable(),
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::keyword("SET").to_matchable(),
                                        Ref::keyword("DROP").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::keyword("NOT").to_matchable(),
                                    Ref::keyword("NULL").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("TYPE").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("SET").to_matchable(),
                                    Ref::new("ColumnDefaultGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("DROP").to_matchable(),
                                    Ref::keyword("DEFAULT").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("SYNC").to_matchable(),
                                    Ref::keyword("IDENTITY").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("SET").to_matchable(),
                                    Ref::new("MaskStatementSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("DROP").to_matchable(),
                                    Ref::keyword("MASK").to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("SetTagsGrammar").to_matchable(),
                                Ref::new("UnsetTagsGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            one_of(vec![
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::keyword("COLUMNS").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Ref::new("IfExistsGrammar").optional().to_matchable(),
                            optionally_bracketed(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ADD").to_matchable(),
                            Ref::new("TableConstraintSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DropConstraintGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            Ref::keyword("FEATURE").to_matchable(),
                            Ref::new("ObjectReferenceSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("TRUNCATE").to_matchable(),
                                Ref::keyword("HISTORY").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ADD").to_matchable(),
                            Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                            AnyNumberOf::new(vec![
                                Ref::new("AlterPartitionGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            Ref::new("IfExistsGrammar").optional().to_matchable(),
                            AnyNumberOf::new(vec![
                                Ref::new("AlterPartitionGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("AlterPartitionGrammar").to_matchable(),
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("LocationGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("AlterPartitionGrammar").to_matchable(),
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("AlterPartitionGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("RECOVER").to_matchable(),
                            Ref::keyword("PARTITIONS").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("RowFilterClauseGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            Ref::keyword("ROW").to_matchable(),
                            Ref::keyword("FILTER").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("TablePropertiesGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("UnsetTablePropertiesGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::keyword("SERDE").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("WITH").to_matchable(),
                                Ref::keyword("SERDEPROPERTIES").to_matchable(),
                                Ref::new("BracketedPropertyListGrammar").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("LocationGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SetOwnerGrammar").to_matchable(),
                        Sequence::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("ALTER").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Ref::new("SetTagsGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("ALTER").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Ref::new("UnsetTagsGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("TableClusterByClauseSegment").to_matchable(),
                        Ref::new("PredictiveOptimizationGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("MATERIALIZED").optional().to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("TablePropertiesGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("UnsetTablePropertiesGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("AS").to_matchable(),
                            Ref::new("SelectStatementSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("WITH").to_matchable(),
                            Ref::keyword("SCHEMA").to_matchable(),
                            one_of(vec![
                                Ref::keyword("BINDING").to_matchable(),
                                Ref::keyword("COMPENSATION").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("TYPE").optional().to_matchable(),
                                    Ref::keyword("EVOLUTION").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SetOwnerGrammar").to_matchable(),
                        Ref::new("SetTagsGrammar").to_matchable(),
                        Ref::new("UnsetTagsGrammar").to_matchable(),
                        Sequence::new(vec![
                            MetaSegment::indent().to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::keyword("ADD").to_matchable(),
                                        Ref::keyword("ALTER").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::keyword("SCHEDULE").to_matchable(),
                                    Ref::keyword("REFRESH").optional().to_matchable(),
                                    Ref::keyword("CRON").to_matchable(),
                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                    Sequence::new(vec![
                                        Ref::keyword("AT").to_matchable(),
                                        Ref::keyword("TIME").to_matchable(),
                                        Ref::keyword("ZONE").to_matchable(),
                                        Ref::new("QuotedLiteralSegment").to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("DROP").to_matchable(),
                                    Ref::keyword("SCHEDULE").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetTimeZoneStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SetTimezoneStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SET").to_matchable(),
                    Ref::keyword("TIME").to_matchable(),
                    Ref::keyword("ZONE").to_matchable(),
                    one_of(vec![
                        Ref::keyword("LOCAL").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("IntervalExpressionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableClusterByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::TableClusterByClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CLUSTER").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                        Ref::keyword("AUTO").to_matchable(),
                        Ref::keyword("NONE").to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "OptimizeTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::OptimizeTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("OPTIMIZE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WHERE").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ZORDER").to_matchable(),
                        Ref::keyword("BY").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StatementSegment".into(),
            NodeMatcher::new(SyntaxKind::Statement, |_dialect| {
                {
                    let dialect = super::sparksql::raw_dialect();
                    dialect
                        .grammar("StatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("AlterCatalogStatementSegment").to_matchable(),
                        Ref::new("CreateCatalogStatementSegment").to_matchable(),
                        Ref::new("DropCatalogStatementSegment").to_matchable(),
                        Ref::new("UseCatalogStatementSegment").to_matchable(),
                        Ref::new("AlterVolumeStatementSegment").to_matchable(),
                        Ref::new("CreateVolumeStatementSegment").to_matchable(),
                        Ref::new("DropVolumeStatementSegment").to_matchable(),
                        Ref::new("CreateDatabaseStatementSegment").to_matchable(),
                        Ref::new("SetTimeZoneStatementSegment").to_matchable(),
                        Ref::new("OptimizeTableStatementSegment").to_matchable(),
                        Ref::new("CreateDatabricksFunctionStatementSegment").to_matchable(),
                        Ref::new("FunctionParameterListGrammarWithComments").to_matchable(),
                        Ref::new("DeclareOrReplaceVariableStatementSegment").to_matchable(),
                        Ref::new("CommentOnStatementSegment").to_matchable(),
                        Ref::new("TagStatementSegment").to_matchable(),
                        Ref::new("UnsetTagStatementSegment").to_matchable(),
                        Ref::new("MagicCellStatementSegment").to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "FunctionParameterListGrammarWithComments".into(),
            NodeMatcher::new(SyntaxKind::FunctionParameterListWithComments, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("FunctionParameterGrammar").to_matchable(),
                            AnyNumberOf::new(vec![
                                Sequence::new(vec![
                                    Ref::keyword("DEFAULT").to_matchable(),
                                    Ref::new("LiteralGrammar").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                                Ref::new("CommentClauseSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FunctionDefinitionGrammar".into(),
            NodeMatcher::new(SyntaxKind::FunctionDefinition, |_dialect| {
                Sequence::new(vec![
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::keyword("LANGUAGE").to_matchable(),
                            one_of(vec![
                                Ref::keyword("SQL").to_matchable(),
                                Ref::keyword("PYTHON").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("DETERMINISTIC").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("NOT").to_matchable(),
                                    Ref::keyword("DETERMINISTIC").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::new("CommentClauseSegment").optional().to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("CONTAINS").to_matchable(),
                                    Ref::keyword("SQL").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("READS").to_matchable(),
                                    Ref::keyword("SQL").to_matchable(),
                                    Ref::keyword("DATA").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("AS").to_matchable(),
                                    one_of(vec![
                                        Ref::new("DoubleQuotedUDFBody").to_matchable(),
                                        Ref::new("SingleQuotedUDFBody").to_matchable(),
                                        Ref::new("DollarQuotedUDFBody").to_matchable(),
                                        Bracketed::new(vec![
                                            one_of(vec![
                                                Ref::new("ExpressionSegment").to_matchable(),
                                                Ref::new("SelectStatementSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("RETURN").to_matchable(),
                                    one_of(vec![
                                        Ref::new("ExpressionSegment").to_matchable(),
                                        Ref::new("SelectStatementSegment").to_matchable(),
                                        Ref::new("WithCompoundStatementSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateDatabricksFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateSqlFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::new("TemporaryGrammar").optional().to_matchable(),
                    Ref::keyword("FUNCTION").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                    Ref::new("FunctionParameterListGrammarWithComments").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("RETURNS").to_matchable(),
                        one_of(vec![
                            Ref::new("DatatypeSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("TABLE").to_matchable(),
                                Sequence::new(vec![
                                    Bracketed::new(vec![
                                        Delimited::new(vec![
                                            Sequence::new(vec![
                                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                                Ref::new("DatatypeSegment").to_matchable(),
                                                Ref::new("CommentGrammar")
                                                    .optional()
                                                    .to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("FunctionDefinitionGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "NamedArgumentSegment".into(),
            NodeMatcher::new(SyntaxKind::NamedArgument, |_dialect| {
                Sequence::new(vec![
                    Ref::new("NakedIdentifierSegment").to_matchable(),
                    Ref::new("RightArrowSegment").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AliasExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::AliasExpression, |_dialect| {
                Sequence::new(vec![
                    MetaSegment::indent().to_matchable(),
                    Ref::new("AsAliasOperatorSegment").optional().to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("SingleIdentifierGrammar")
                                .optional()
                                .to_matchable(),
                            Bracketed::new(vec![
                                Ref::new("SingleIdentifierListSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                    ])
                    .config(|this| {
                        this.exclude = Some(
                            one_of(vec![
                                Ref::keyword("LATERAL").to_matchable(),
                                Ref::new("JoinTypeKeywords").to_matchable(),
                                Ref::keyword("WINDOW").to_matchable(),
                                Ref::keyword("PIVOT").to_matchable(),
                                Ref::keyword("KEYS").to_matchable(),
                                Ref::keyword("FROM").to_matchable(),
                                Ref::keyword("FOR").to_matchable(),
                            ])
                            .to_matchable(),
                        );
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "GroupByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::GroupbyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("GROUP").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Ref::keyword("ALL").to_matchable(),
                        Delimited::new(vec![
                            Ref::new("CubeRollupClauseSegment").to_matchable(),
                            Ref::new("GroupingSetsClauseSegment").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Delimited::new(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            one_of(vec![
                                Ref::new("WithCubeRollupClauseSegment").to_matchable(),
                                Ref::new("GroupingSetsClauseSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnConstraintSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnConstraintSegment, |_dialect| {
                Sequence::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("CONSTRAINT").to_matchable(),
                        Ref::new("ObjectReferenceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("PrimaryKeyGrammar").to_matchable(),
                            Ref::new("ConstraintOptionGrammar")
                                .optional()
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("ForeignKeyGrammar").optional().to_matchable(),
                            Ref::keyword("REFERENCES").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                            Ref::new("BracketedColumnReferenceListGrammar")
                                .optional()
                                .to_matchable(),
                            one_of(vec![
                                Ref::new("ForeignKeyOptionGrammar").to_matchable(),
                                Ref::new("ConstraintOptionGrammar").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTableUsingStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTableUsingStatement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Sequence::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("CREATE").to_matchable(),
                                Ref::keyword("OR").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Ref::keyword("REPLACE").to_matchable(),
                            Ref::keyword("TABLE").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("CREATE").to_matchable(),
                            Ref::keyword("EXTERNAL").optional().to_matchable(),
                            Ref::keyword("TABLE").to_matchable(),
                            Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("TableSpecificationSegment")
                        .optional()
                        .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("USING").to_matchable(),
                        Ref::new("DataSourceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    AnyNumberOf::new(vec![Ref::new("TableClausesSegment").to_matchable()])
                        .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        one_of(vec![
                            Ref::new("SelectStatementSegment").to_matchable(),
                            Ref::new("ValuesClauseSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableSpecificationSegment".into(),
            NodeMatcher::new(SyntaxKind::TableSpecificationSegment, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("DatatypeSegment").to_matchable(),
                            AnyNumberOf::new(vec![
                                Ref::new("ColumnPropertiesSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnPropertiesSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnPropertiesSegment, |_dialect| {
                one_of(vec![
                    Ref::new("NotNullGrammar").to_matchable(),
                    Ref::new("ColumnGeneratedGrammar").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("DEFAULT").to_matchable(),
                        Ref::new("ColumnConstraintDefaultGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("CommentGrammar").to_matchable(),
                    Ref::new("ColumnConstraintSegment").to_matchable(),
                    Ref::new("MaskStatementSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableClausesSegment".into(),
            NodeMatcher::new(SyntaxKind::TableClausesSegment, |_dialect| {
                one_of(vec![
                    Ref::new("PartitionClauseSegment").to_matchable(),
                    Ref::new("TableClusterByClauseSegment").to_matchable(),
                    Ref::new("LocationWithCredentialGrammar").to_matchable(),
                    Ref::new("OptionsGrammar").to_matchable(),
                    Ref::new("CommentGrammar").to_matchable(),
                    Ref::new("TablePropertiesGrammar").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Ref::new("RowFilterClauseGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DeclareOrReplaceVariableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DeclareOrReplaceVariableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DECLARE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("VARIABLE").optional().to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::new("DatatypeSegment").optional().to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("DEFAULT").to_matchable(),
                            Ref::new("EqualsSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CommentOnStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CommentClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("COMMENT").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("CATALOG").to_matchable(),
                            Ref::new("CatalogReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("DATABASE").to_matchable(),
                                Ref::keyword("SCHEMA").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("DatabaseReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("TABLE").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("VOLUME").to_matchable(),
                            Ref::new("VolumeReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("CONNECTION").to_matchable(),
                                Ref::keyword("PROVIDER").to_matchable(),
                                Ref::keyword("RECIPIENT").to_matchable(),
                                Ref::keyword("SHARE").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("ObjectReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("IS").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::keyword("NULL").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FunctionNameSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionName, |_dialect| {
                Sequence::new(vec![
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                            Ref::new("DotSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.terminators = vec![Ref::new("BracketedSegment").to_matchable()];
                    })
                    .to_matchable(),
                    Ref::new("FunctionNameIdentifierSegment")
                        .terminators(vec![Ref::new("BracketedSegment").to_matchable()])
                        .to_matchable(),
                ])
                .config(|this| {
                    this.disallow_gaps();
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MagicCellStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::MagicCellSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::new("NotebookStart").optional().to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("MagicStartGrammar").optional().to_matchable(),
                            AnyNumberOf::new(vec![Ref::new("MagicLineGrammar").to_matchable()])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("MagicSingleLineGrammar").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.terminators =
                        vec![Ref::new("CommandCellSegment").optional().to_matchable()];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetVariableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SetVariableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SET").to_matchable(),
                    one_of(vec![
                        Ref::keyword("VAR").to_matchable(),
                        Ref::keyword("VARIABLE").to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Delimited::new(vec![
                                Ref::new("VariableNameIdentifierSegment").to_matchable(),
                                Ref::new("EqualsSegment").to_matchable(),
                                one_of(vec![
                                    Ref::keyword("DEFAULT").to_matchable(),
                                    optionally_bracketed(vec![
                                        Ref::new("ExpressionSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Bracketed::new(vec![
                                Ref::new("VariableNameIdentifierSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("EqualsSegment").to_matchable(),
                            Bracketed::new(vec![
                                one_of(vec![
                                    Ref::new("SelectStatementSegment").to_matchable(),
                                    Ref::new("ValuesClauseSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
    ]);

    databricks_dialect
}
