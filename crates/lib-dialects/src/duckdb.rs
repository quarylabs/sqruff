use sqruff_lib_core::dialects::Dialect;
use sqruff_lib_core::dialects::init::DialectKind;
use sqruff_lib_core::dialects::syntax::SyntaxKind;
use sqruff_lib_core::helpers::{Config, ToMatchable};
use sqruff_lib_core::parser::grammar::anyof::{AnyNumberOf, one_of, optionally_bracketed};
use sqruff_lib_core::parser::grammar::delimited::Delimited;
use sqruff_lib_core::parser::grammar::sequence::{Bracketed, Sequence};
use sqruff_lib_core::parser::grammar::{Nothing, Ref};
use sqruff_lib_core::parser::lexer::Matcher;
use sqruff_lib_core::parser::matchable::MatchableTrait;
use sqruff_lib_core::parser::node_matcher::NodeMatcher;
use sqruff_lib_core::parser::parsers::{RegexParser, StringParser, TypedParser};
use sqruff_lib_core::parser::segments::meta::MetaSegment;
use sqruff_lib_core::parser::types::ParseMode;

pub fn dialect() -> Dialect {
    raw_dialect().config(|this| this.expand())
}

pub fn raw_dialect() -> Dialect {
    let ansi_dialect = super::ansi::raw_dialect();
    let postgres_dialect = super::postgres::raw_dialect();
    let mut duckdb_dialect = postgres_dialect.clone();
    duckdb_dialect.name = DialectKind::Duckdb;

    duckdb_dialect.sets_mut("reserved_keywords").extend([
        "LAMBDA",
        "PIVOT",
        "PIVOT_LONGER",
        "PIVOT_WIDER",
        "UNPIVOT",
    ]);

    duckdb_dialect.sets_mut("unreserved_keywords").extend([
        "ANTI",
        "APPEND",
        "ASOF",
        "COMPRESSION",
        "COMPRESSION_LEVEL",
        "GLOB",
        "MACRO",
        "MAP",
        "OVERWRITE",
        "OVERWRITE_OR_IGNORE",
        "PARQUET_VERSION",
        "PARTITION_BY",
        "POSITIONAL",
        "PROGRAM",
        "ROW_GROUP_SIZE",
        "ROW_GROUP_SIZE_BYTES",
        "SEMI",
        "STRUCT",
        "VIRTUAL",
        "WRITE_PARTITION_COLUMNS",
    ]);

    duckdb_dialect.add([
        (
            "LambdaArrowSegment".into(),
            StringParser::new("->", SyntaxKind::LambdaArrow)
                .to_matchable()
                .into(),
        ),
        (
            "OrIgnoreGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("OR").to_matchable(),
                Ref::keyword("IGNORE").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "EqualsSegment_a".into(),
            StringParser::new("==", SyntaxKind::ComparisonOperator)
                .to_matchable()
                .into(),
        ),
        (
            "UnpackingOperatorSegment".into(),
            TypedParser::new(SyntaxKind::Star, SyntaxKind::Symbol)
                .to_matchable()
                .into(),
        ),
    ]);

    duckdb_dialect.replace_grammar(
        "FunctionNameIdentifierSegment",
        RegexParser::new(r#"[A-Z_][A-Z0-9_$]*"#, SyntaxKind::FunctionNameIdentifier)
            .anti_template("^(STRUCT|UNION|ENUM)$")
            .to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "DivideSegment",
        one_of(vec![
            StringParser::new("//", SyntaxKind::BinaryOperator).to_matchable(),
            StringParser::new("/", SyntaxKind::BinaryOperator).to_matchable(),
        ])
        .to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "CreateTableAsStatementSegment",
        Nothing::new().to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "UnionGrammar",
        ansi_dialect.grammar("UnionGrammar").copy(
            Some(vec![
                Sequence::new(vec![
                    Ref::keyword("BY").to_matchable(),
                    Ref::keyword("NAME").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    duckdb_dialect.replace_grammar(
        "JoinLikeClauseGrammar",
        Sequence::new(vec![
            AnyNumberOf::new(vec![
                Ref::new("FromPivotExpressionSegment").to_matchable(),
                Ref::new("FromUnpivotExpressionSegment").to_matchable(),
            ])
            .config(|this| {
                this.min_times(1);
            })
            .to_matchable(),
            Ref::new("AliasExpressionSegment").optional().to_matchable(),
        ])
        .to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "NonSetSelectableGrammar",
        postgres_dialect.grammar("NonSetSelectableGrammar").copy(
            Some(vec![
                Ref::new("SimplifiedPivotExpressionSegment").to_matchable(),
                Ref::new("SimplifiedUnpivotExpressionSegment").to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    duckdb_dialect.replace_grammar(
        "NonStandardJoinTypeKeywordsGrammar",
        one_of(vec![
            Ref::keyword("ANTI").to_matchable(),
            Ref::keyword("SEMI").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ASOF").to_matchable(),
                one_of(vec![
                    Ref::new("JoinTypeKeywordsGrammar").to_matchable(),
                    Ref::keyword("ANTI").to_matchable(),
                    Ref::keyword("SEMI").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable(),
        ])
        .to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "HorizontalJoinKeywordsGrammar",
        Ref::keyword("POSITIONAL").to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "FunctionContentsExpressionGrammar",
        one_of(vec![
            Ref::new("LambdaExpressionSegment").to_matchable(),
            Ref::new("NamedArgumentSegment").to_matchable(),
            Ref::new("ExpressionSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "ColumnsExpressionNameGrammar",
        Sequence::new(vec![
            Ref::new("UnpackingOperatorSegment")
                .optional()
                .to_matchable(),
            Ref::keyword("COLUMNS").to_matchable(),
        ])
        .to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "ColumnsExpressionGrammar",
        Sequence::new(vec![
            Ref::new("ColumnsExpressionFunctionNameSegment").to_matchable(),
            Ref::new("ColumnsExpressionFunctionContentsSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "QuotedIdentifierSegment",
        TypedParser::new(SyntaxKind::DoubleQuote, SyntaxKind::QuotedIdentifier).to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "SingleQuotedIdentifierSegment",
        TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::QuotedIdentifier).to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "ListComprehensionGrammar",
        Ref::new("ListComprehensionExpressionSegment").to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "InOperatorGrammar",
        Sequence::new(vec![
            Ref::keyword("NOT").optional().to_matchable(),
            Ref::keyword("IN").to_matchable(),
            one_of(vec![
                Bracketed::new(vec![
                    one_of(vec![
                        Delimited::new(vec![Ref::new("Expression_A_Grammar").to_matchable()])
                            .config(|this| {
                                this.allow_trailing();
                            })
                            .to_matchable(),
                        Ref::new("SelectableGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.parse_mode(ParseMode::Greedy);
                })
                .to_matchable(),
                Ref::new("FunctionSegment").to_matchable(),
                Ref::new("ArrayLiteralSegment").to_matchable(),
                Ref::new("QuotedLiteralSegment").to_matchable(),
                Ref::new("ColumnReferenceSegment").to_matchable(),
            ])
            .to_matchable(),
        ])
        .to_matchable(),
    );

    duckdb_dialect.replace_grammar(
        "ComparisonOperatorGrammar",
        ansi_dialect.grammar("ComparisonOperatorGrammar").copy(
            Some(vec![
                Ref::new("EqualsSegment_a").to_matchable(),
                Ref::new("GlobOperatorSegment").to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    duckdb_dialect.replace_grammar(
        "LikeGrammar",
        postgres_dialect.grammar("LikeGrammar").copy(
            Some(vec![Ref::keyword("GLOB").to_matchable()]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    duckdb_dialect.replace_grammar(
        "FilterClauseGrammar",
        Sequence::new(vec![
            Ref::keyword("FILTER").to_matchable(),
            Bracketed::new(vec![
                Sequence::new(vec![
                    Ref::keyword("WHERE").optional().to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable(),
        ])
        .to_matchable(),
    );

    duckdb_dialect.insert_lexer_matchers(
        vec![Matcher::string(
            "double_divide",
            r#"//"#,
            SyntaxKind::DoubleDivide,
        )],
        "divide",
    );

    duckdb_dialect.patch_lexer_matchers(vec![
        Matcher::regex("single_quote", r#"'([^']|'')*'"#, SyntaxKind::SingleQuote),
        Matcher::regex("double_quote", r#""([^"]|"")*""#, SyntaxKind::DoubleQuote),
        Matcher::regex("equals", r#"==?"#, SyntaxKind::RawComparisonOperator),
    ]);

    duckdb_dialect.add([
        (
            "StructTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::StructType, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("STRUCT").to_matchable(),
                    Ref::new("StructTypeSchemaSegment")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StructTypeSchemaSegment".into(),
            NodeMatcher::new(SyntaxKind::StructTypeSchema, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::new("DatatypeSegment").to_matchable(),
                                Sequence::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MapTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::MapType, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("MAP").to_matchable(),
                    Ref::new("MapTypeSchemaSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MapTypeSchemaSegment".into(),
            NodeMatcher::new(SyntaxKind::MapTypeSchema, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![Ref::new("DatatypeSegment").to_matchable()]).to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "InsertStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::InsertStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INSERT").to_matchable(),
                    one_of(vec![
                        Ref::new("OrReplaceGrammar").to_matchable(),
                        Ref::new("OrIgnoreGrammar").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("INTO").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("AsAliasExpressionSegment")
                        .optional()
                        .to_matchable(),
                    one_of(vec![
                        Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("BY").to_matchable(),
                            Ref::keyword("POSITION").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("BY").to_matchable(),
                            Ref::keyword("NAME").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("DEFAULT").to_matchable(),
                            Ref::keyword("VALUES").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SelectStatementSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::new("BracketedColumnReferenceListGrammar")
                                .optional()
                                .to_matchable(),
                            one_of(vec![
                                Ref::new("ValuesClauseSegment").to_matchable(),
                                optionally_bracketed(vec![
                                    Ref::new("SelectStatementSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ON").to_matchable(),
                        Ref::keyword("CONFLICT").to_matchable(),
                        Ref::new("ConflictTargetSegment").optional().to_matchable(),
                        Ref::new("ConflictActionSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("RETURNING").to_matchable(),
                        one_of(vec![
                            Ref::new("StarSegment").to_matchable(),
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ExpressionSegment").to_matchable(),
                                    Ref::new("AsAliasExpressionSegment")
                                        .optional()
                                        .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnConstraintSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnConstraintSegment, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("NOT").optional().to_matchable(),
                            Ref::keyword("NULL").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("CHECK").to_matchable(),
                            Bracketed::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DEFAULT").to_matchable(),
                            one_of(vec![
                                Ref::new("LiteralGrammar").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("UNIQUE").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("PRIMARY").to_matchable(),
                            Ref::keyword("KEY").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ReferenceDefinitionGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("COLLATE").to_matchable(),
                            Ref::new("CollationReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::new("TemporaryGrammar").optional().to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("AS").to_matchable(),
                            optionally_bracketed(vec![
                                Ref::new("SelectableGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                    one_of(vec![
                                        Sequence::new(vec![
                                            Ref::new("DatatypeSegment").to_matchable(),
                                            AnyNumberOf::new(vec![
                                                one_of(vec![
                                                    Ref::new("ColumnConstraintSegment")
                                                        .to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                        Sequence::new(vec![
                                            Ref::new("DatatypeSegment")
                                                .exclude(Ref::keyword("AS"))
                                                .optional()
                                                .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("GENERATED").to_matchable(),
                                                Ref::keyword("ALWAYS").to_matchable(),
                                            ])
                                            .config(|this| {
                                                this.optional();
                                            })
                                            .to_matchable(),
                                            Ref::keyword("AS").to_matchable(),
                                            Bracketed::new(vec![
                                                Ref::new("ExpressionSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            one_of(vec![
                                                Ref::keyword("STORED").to_matchable(),
                                                Ref::keyword("VIRTUAL").to_matchable(),
                                            ])
                                            .config(|this| {
                                                this.optional();
                                            })
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("TableConstraintSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WildcardExcludeExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::WildcardExclude, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("EXCLUDE").to_matchable(),
                    one_of(vec![
                        Ref::new("ColumnReferenceSegment").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                                .config(|this| {
                                    this.allow_trailing();
                                })
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WildcardReplaceExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::WildcardReplace, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("REPLACE").to_matchable(),
                    one_of(vec![
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("BaseExpressionElementGrammar").to_matchable(),
                                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.allow_trailing();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("BaseExpressionElementGrammar").to_matchable(),
                            Ref::new("AliasExpressionSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WildcardRenameExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::WildcardRename, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("RENAME").to_matchable(),
                    one_of(vec![
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("BaseExpressionElementGrammar").to_matchable(),
                                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.allow_trailing();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("BaseExpressionElementGrammar").to_matchable(),
                            Ref::new("AliasExpressionSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WildcardPatternMatchingSegment".into(),
            NodeMatcher::new(SyntaxKind::WildcardPatternMatching, |_dialect| {
                one_of(vec![
                    Ref::new("LikeExpressionGrammar").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::new("LikeOperatorSegment").to_matchable(),
                            Ref::new("GlobOperatorSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WildcardExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::WildcardExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::new("WildcardIdentifierSegment").to_matchable(),
                    Ref::new("WildcardExcludeExpressionSegment")
                        .optional()
                        .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("WildcardReplaceExpressionSegment")
                                .optional()
                                .to_matchable(),
                            Ref::new("WildcardRenameExpressionSegment")
                                .optional()
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("WildcardPatternMatchingSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectClauseElementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectClauseElement, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![Ref::new("WildcardExpressionSegment").to_matchable()])
                        .to_matchable(),
                    Sequence::new(vec![
                        Ref::new("BaseExpressionElementGrammar").to_matchable(),
                        Ref::new("AliasExpressionSegment").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnsExpressionFunctionContentsSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionContents, |_dialect| {
                Sequence::new(vec![
                    Bracketed::new(vec![
                        one_of(vec![
                            Ref::new("WildcardExpressionSegment").to_matchable(),
                            Ref::new("LambdaExpressionSegment").to_matchable(),
                            Ref::new("BaseExpressionElementGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LambdaExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::LambdaFunction, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::new("ParameterNameSegment").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("LambdaArrowSegment").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("LAMBDA").to_matchable(),
                        one_of(vec![
                            Ref::new("ParameterNameSegment").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ColonSegment").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ListComprehensionExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::ListComprehension, |_dialect| {
                Bracketed::new(vec![
                    Ref::new("ExpressionSegment").to_matchable(),
                    Ref::keyword("FOR").to_matchable(),
                    Ref::new("ParameterNameSegment").to_matchable(),
                    Ref::keyword("IN").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("IF").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .config(|this| {
                    this.bracket_type("square");
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("SelectStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("QualifyClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    Some(Ref::new("OrderByClauseSegment").optional().to_matchable()),
                    None,
                    vec![
                        Ref::new("SetOperatorSegment").to_matchable(),
                        Ref::new("WithNoSchemaBindingClauseSegment").to_matchable(),
                        Ref::new("WithDataClauseSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ON").to_matchable(),
                            Ref::keyword("CONFLICT").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("RETURNING").to_matchable(),
                        Ref::new("WithCheckOptionSegment").to_matchable(),
                        Ref::new("MetaCommandQueryBufferSegment").to_matchable(),
                    ],
                    true,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnorderedSelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("SelectClauseSegment").to_matchable(),
                            Ref::new("FromClauseSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("FromClauseSegment").to_matchable(),
                            Ref::new("SelectClauseSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("WhereClauseSegment").optional().to_matchable(),
                    Ref::new("GroupByClauseSegment").optional().to_matchable(),
                    Ref::new("HavingClauseSegment").optional().to_matchable(),
                    Ref::new("NamedWindowSegment").optional().to_matchable(),
                    Ref::new("QualifyClauseSegment").optional().to_matchable(),
                ])
                .config(|this| {
                    this.terminators = vec![
                        Ref::new("SetOperatorSegment").to_matchable(),
                        Ref::new("OrderByClauseSegment").to_matchable(),
                        Ref::new("LimitClauseSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ON").to_matchable(),
                            Ref::keyword("CONFLICT").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("RETURNING").to_matchable(),
                    ];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::TableReference, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("ObjectReferenceSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("SingleQuotedIdentifierSegment").to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "AliasExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::AliasExpression, |_dialect| {
                let dialect = super::ansi::raw_dialect();
                dialect
                    .grammar("AliasExpressionSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "OrderByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::OrderbyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ORDER").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("ALL").to_matchable(),
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            one_of(vec![
                                Ref::keyword("ASC").to_matchable(),
                                Ref::keyword("DESC").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("NULLS").to_matchable(),
                                one_of(vec![
                                    Ref::keyword("FIRST").to_matchable(),
                                    Ref::keyword("LAST").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.allow_trailing();
                        this.terminators =
                            vec![Ref::new("OrderByClauseTerminators").to_matchable()];
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "GroupByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::GroupbyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("GROUP").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Delimited::new(vec![
                        one_of(vec![
                            Ref::keyword("ALL").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.allow_trailing();
                        this.terminators =
                            vec![Ref::new("GroupByClauseTerminatorGrammar").to_matchable()];
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "QualifyClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::QualifyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("QUALIFY").to_matchable(),
                    MetaSegment::implicit_indent().to_matchable(),
                    optionally_bracketed(vec![Ref::new("ExpressionSegment").to_matchable()])
                        .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ObjectLiteralElementSegment".into(),
            NodeMatcher::new(SyntaxKind::ObjectLiteralElement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::new("NakedIdentifierSegment").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("ColonSegment").to_matchable(),
                    Ref::new("BaseExpressionElementGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StatementSegment".into(),
            NodeMatcher::new(SyntaxKind::Statement, |_dialect| {
                {
                    let dialect = super::postgres::raw_dialect();
                    dialect
                        .grammar("StatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("SimplifiedPivotExpressionSegment").to_matchable(),
                        Ref::new("SimplifiedUnpivotExpressionSegment").to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromPivotExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::FromPivotExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("PIVOT").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("FunctionSegment").to_matchable(),
                                Ref::new("AliasExpressionSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("FOR").to_matchable(),
                        AnyNumberOf::new(vec![
                            Sequence::new(vec![
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                Ref::keyword("IN").to_matchable(),
                                Bracketed::new(vec![
                                    Delimited::new(vec![Ref::new("LiteralGrammar").to_matchable()])
                                        .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("GroupByClauseSegment").optional().to_matchable(),
                        Ref::new("OrderByClauseSegment").optional().to_matchable(),
                        Ref::new("LimitClauseSegment").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SimplifiedPivotExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::SimplifiedPivot, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("PIVOT").to_matchable(),
                        Ref::keyword("PIVOT_WIDER").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("TableExpressionSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ON").to_matchable(),
                        Delimited::new(vec![
                            one_of(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("IN").to_matchable(),
                                Bracketed::new(vec![
                                    Delimited::new(vec![Ref::new("LiteralGrammar").to_matchable()])
                                        .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("USING").to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("FunctionSegment").to_matchable(),
                                Ref::new("AliasExpressionSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("GroupByClauseSegment").optional().to_matchable(),
                    Ref::new("OrderByClauseSegment").optional().to_matchable(),
                    Ref::new("LimitClauseSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromUnpivotExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::FromUnpivotExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UNPIVOT").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("INCLUDE").to_matchable(),
                        Ref::keyword("NULLS").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Bracketed::new(vec![
                        one_of(vec![
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("FOR").to_matchable(),
                        AnyNumberOf::new(vec![
                            Sequence::new(vec![
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                Ref::keyword("IN").to_matchable(),
                                Bracketed::new(vec![
                                    Delimited::new(vec![
                                        Sequence::new(vec![
                                            optionally_bracketed(vec![
                                                Delimited::new(vec![
                                                    Ref::new("SingleIdentifierGrammar")
                                                        .to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Ref::new("AliasExpressionSegment")
                                                .optional()
                                                .to_matchable(),
                                        ])
                                        .to_matchable(),
                                        Ref::new("ColumnsExpressionGrammar").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.min_times(1);
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SimplifiedUnpivotExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::SimplifiedUnpivot, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("UNPIVOT").to_matchable(),
                        Ref::keyword("PIVOT_LONGER").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("TableExpressionSegment").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Bracketed::new(vec![
                                    Delimited::new(vec![
                                        Ref::new("ColumnReferenceSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("AliasExpressionSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ColumnsExpressionGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("INTO").to_matchable(),
                    Ref::keyword("NAME").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::keyword("VALUE").to_matchable(),
                    Delimited::new(vec![Ref::new("SingleIdentifierGrammar").to_matchable()])
                        .to_matchable(),
                    Ref::new("OrderByClauseSegment").optional().to_matchable(),
                    Ref::new("LimitClauseSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::new("TemporaryGrammar").optional().to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("BracketedColumnReferenceListGrammar")
                        .optional()
                        .to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    one_of(vec![
                        optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                            .to_matchable(),
                        Ref::new("ValuesClauseSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::new("TemporaryGrammar").optional().to_matchable(),
                    one_of(vec![
                        Ref::keyword("MACRO").to_matchable(),
                        Ref::keyword("FUNCTION").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                    Ref::new("FunctionParameterListGrammar").to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("TABLE").to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            Ref::new("SelectableGrammar").to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    one_of(vec![
                        Ref::keyword("MACRO").to_matchable(),
                        Ref::keyword("FUNCTION").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("TABLE").optional().to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                    Ref::new("DropBehaviorGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTypeStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTypeStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("TYPE").to_matchable(),
                    Ref::new("DatatypeSegment").to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    one_of(vec![
                        Ref::new("DatatypeSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ENUM").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("StructTypeSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("UNION").to_matchable(),
                            Ref::new("StructTypeSchemaSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CopyStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CopyStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("COPY").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::new("TableReferenceSegment").to_matchable(),
                                    Bracketed::new(vec![
                                        Delimited::new(vec![
                                            Ref::new("ColumnReferenceSegment").to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Bracketed::new(vec![Ref::new("SelectableGrammar").to_matchable()])
                                    .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("WITH").optional().to_matchable(),
                                Bracketed::new(vec![
                                    Delimited::new(vec![
                                        one_of(vec![
                                            Sequence::new(vec![
                                                Ref::keyword("FORMAT").to_matchable(),
                                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("OVERWRITE_OR_IGNORE").to_matchable(),
                                                Ref::new("BooleanLiteralGrammar")
                                                    .optional()
                                                    .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("OVERWRITE").to_matchable(),
                                                Ref::new("BooleanLiteralGrammar")
                                                    .optional()
                                                    .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("APPEND").to_matchable(),
                                                Ref::new("BooleanLiteralGrammar")
                                                    .optional()
                                                    .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("PARTITION_BY").to_matchable(),
                                                one_of(vec![
                                                    Bracketed::new(vec![
                                                        Delimited::new(vec![
                                                            Ref::new("ColumnReferenceSegment")
                                                                .to_matchable(),
                                                        ])
                                                        .to_matchable(),
                                                    ])
                                                    .to_matchable(),
                                                    Ref::new("ColumnReferenceSegment")
                                                        .to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("WRITE_PARTITION_COLUMNS")
                                                    .to_matchable(),
                                                Ref::new("BooleanLiteralGrammar")
                                                    .optional()
                                                    .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("COMPRESSION").to_matchable(),
                                                one_of(vec![
                                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                                    Ref::new("SingleIdentifierGrammar")
                                                        .to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("COMPRESSION_LEVEL").to_matchable(),
                                                Ref::new("NumericLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("ROW_GROUP_SIZE_BYTES").to_matchable(),
                                                Ref::new("NumericLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("ROW_GROUP_SIZE").to_matchable(),
                                                Ref::new("NumericLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("PARQUET_VERSION").to_matchable(),
                                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Sequence::new(vec![
                                Ref::new("TableReferenceSegment").to_matchable(),
                                Bracketed::new(vec![
                                    Delimited::new(vec![
                                        Ref::new("ColumnReferenceSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("FROM").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("WITH").optional().to_matchable(),
                                Bracketed::new(vec![
                                    Delimited::new(vec![
                                        AnyNumberOf::new(vec![
                                            Sequence::new(vec![
                                                Ref::keyword("FORMAT").to_matchable(),
                                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("FREEZE").to_matchable(),
                                                Ref::new("BooleanLiteralGrammar")
                                                    .optional()
                                                    .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("DELIMITER").to_matchable(),
                                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("NULL").to_matchable(),
                                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("HEADER").to_matchable(),
                                                Ref::new("BooleanLiteralGrammar")
                                                    .optional()
                                                    .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("QUOTE").to_matchable(),
                                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("ESCAPE").to_matchable(),
                                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("FORCE_QUOTE").to_matchable(),
                                                one_of(vec![
                                                    Bracketed::new(vec![
                                                        Delimited::new(vec![
                                                            Ref::new("ColumnReferenceSegment")
                                                                .to_matchable(),
                                                        ])
                                                        .to_matchable(),
                                                    ])
                                                    .to_matchable(),
                                                    Ref::new("StarSegment").to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("FORCE_NOT_NULL").to_matchable(),
                                                Bracketed::new(vec![
                                                    Delimited::new(vec![
                                                        Ref::new("ColumnReferenceSegment")
                                                            .to_matchable(),
                                                    ])
                                                    .to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("FORCE_NULL").to_matchable(),
                                                Bracketed::new(vec![
                                                    Delimited::new(vec![
                                                        Ref::new("ColumnReferenceSegment")
                                                            .to_matchable(),
                                                    ])
                                                    .to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("ENCODING").to_matchable(),
                                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .config(|this| {
                                            this.max_times_per_element = Some(1);
                                        })
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayLiteralSegment".into(),
            NodeMatcher::new(SyntaxKind::ArrayLiteral, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Ref::new("BaseExpressionElementGrammar").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                        this.allow_trailing();
                    })
                    .to_matchable(),
                ])
                .config(|this| {
                    this.bracket_type("square");
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
    ]);

    duckdb_dialect
}
