use itertools::Itertools;
use sqruff_lib_core::dialects::Dialect;
use sqruff_lib_core::dialects::init::DialectKind;
use sqruff_lib_core::dialects::syntax::SyntaxKind;
use sqruff_lib_core::helpers::{Config, ToMatchable};
use sqruff_lib_core::parser::grammar::anyof::{AnyNumberOf, one_of, optionally_bracketed};
use sqruff_lib_core::parser::grammar::delimited::Delimited;
use sqruff_lib_core::parser::grammar::sequence::{Bracketed, Sequence};
use sqruff_lib_core::parser::grammar::{Anything, Nothing, Ref};
use sqruff_lib_core::parser::lexer::Matcher;
use sqruff_lib_core::parser::matchable::MatchableTrait;
use sqruff_lib_core::parser::node_matcher::NodeMatcher;
use sqruff_lib_core::parser::parsers::{RegexParser, StringParser};
use sqruff_lib_core::parser::segments::generator::SegmentGenerator;
use sqruff_lib_core::parser::segments::meta::MetaSegment;

use super::redshift_keywords::{REDSHIFT_RESERVED_KEYWORDS, REDSHIFT_UNRESERVED_KEYWORDS};

pub fn dialect() -> Dialect {
    raw_dialect().config(|this| this.expand())
}

pub fn raw_dialect() -> Dialect {
    let postgres_dialect = super::postgres::raw_dialect();
    let ansi_dialect = super::ansi::raw_dialect();
    let mut redshift_dialect = postgres_dialect.clone();
    redshift_dialect.name = DialectKind::Redshift;

    redshift_dialect.sets_mut("unreserved_keywords").clear();

    redshift_dialect.update_keywords_set_from_multiline_string(
        "unreserved_keywords",
        REDSHIFT_UNRESERVED_KEYWORDS,
    );

    redshift_dialect.sets_mut("reserved_keywords").clear();

    redshift_dialect
        .update_keywords_set_from_multiline_string("reserved_keywords", REDSHIFT_RESERVED_KEYWORDS);

    redshift_dialect.sets_mut("bare_functions").clear();

    redshift_dialect.sets_mut("bare_functions").extend([
        "current_date",
        "sysdate",
        "current_time",
        "current_timestamp",
        "user",
        "current_user",
        "current_aws_account",
        "current_namespace",
        "current_user_id",
    ]);

    redshift_dialect
        .sets_mut("date_part_function_name")
        .extend(["DATEADD", "DATEDIFF", "EXTRACT", "DATE_PART"]);

    redshift_dialect.sets_mut("datetime_units").extend([
        "MILLENNIUM",
        "MILLENNIA",
        "MIL",
        "MILS",
        "CENTURY",
        "CENTURIES",
        "C",
        "CENT",
        "CENTS",
        "DECADE",
        "DECADES",
        "DEC",
        "DECS",
        "EPOCH",
        "YEAR",
        "YEARS",
        "Y",
        "YR",
        "YRS",
        "QUARTER",
        "QUARTERS",
        "QTR",
        "QTRS",
        "MONTH",
        "MONTHS",
        "MON",
        "MONS",
        "WEEK",
        "WEEKS",
        "W",
        "DAYOFWEEK",
        "DOW",
        "DW",
        "WEEKDAY",
        "DAYOFYEAR",
        "DOY",
        "DY",
        "YEARDAY",
        "DAY",
        "DAYS",
        "D",
        "HOUR",
        "HOURS",
        "H",
        "HR",
        "HRS",
        "MINUTE",
        "MINUTES",
        "M",
        "MIN",
        "MINS",
        "SECOND",
        "SECONDS",
        "S",
        "SEC",
        "SECS",
        "MILLISECOND",
        "MILLISECONDS",
        "MS",
        "MSEC",
        "MSECS",
        "MSECOND",
        "MSECONDS",
        "MILLISEC",
        "MILLISECS",
        "MILLISECON",
        "MICROSECOND",
        "MICROSECONDS",
        "MICROSEC",
        "MICROSECS",
        "MICROSECOND",
        "USECOND",
        "USECONDS",
        "US",
        "USEC",
        "USECS",
        "TIMEZONE",
        "TIMEZONE_HOUR",
        "TIMEZONE_MINUTE",
    ]);

    redshift_dialect.add([(
        "NakedIdentifierSegment".into(),
        SegmentGenerator::new(|dialect| {
            let reserved_keywords = dialect.sets("reserved_keywords");
            let pattern = reserved_keywords.iter().join("|");
            let anti_template = format!("^({pattern})$");
            RegexParser::new(
                r#"#?([A-Z_]+|[0-9]+[A-Z_$])[A-Z0-9_$]*"#,
                SyntaxKind::NakedIdentifier,
            )
            .anti_template(&anti_template)
            .to_matchable()
        })
        .into(),
    )]);

    redshift_dialect.replace_grammar(
        "WellKnownTextGeometrySegment",
        Nothing::new().to_matchable(),
    );

    redshift_dialect.replace_grammar(
        "JoinLikeClauseGrammar",
        Sequence::new(vec![
            AnyNumberOf::new(vec![
                Ref::new("FromPivotExpressionSegment").to_matchable(),
                Ref::new("FromUnpivotExpressionSegment").to_matchable(),
            ])
            .config(|this| {
                this.max_times_per_element = Some(1);
                this.min_times(1);
            })
            .to_matchable(),
            Ref::new("AliasExpressionSegment").optional().to_matchable(),
        ])
        .to_matchable(),
    );

    redshift_dialect.replace_grammar(
        "LiteralGrammar",
        ansi_dialect.grammar("LiteralGrammar").copy(
            Some(vec![
                Ref::new("MaxLiteralSegment").to_matchable(),
                Ref::new("DollarNumericLiteralSegment").to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    redshift_dialect.patch_lexer_matchers(vec![Matcher::regex(
        "word",
        r#"#?[0-9a-zA-Z_]+[0-9a-zA-Z_$]*"#,
        SyntaxKind::Word,
    )]);

    redshift_dialect.add([
        (
            "CompressionTypeGrammar".into(),
            one_of(vec![
                Ref::keyword("BZIP2").to_matchable(),
                Ref::keyword("GZIP").to_matchable(),
                Ref::keyword("LZOP").to_matchable(),
                Ref::keyword("ZSTD").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ArgModeGrammar".into(),
            one_of(vec![
                Ref::keyword("IN").to_matchable(),
                Ref::keyword("OUT").to_matchable(),
                Ref::keyword("INOUT").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ColumnEncodingGrammar".into(),
            one_of(vec![
                Ref::keyword("RAW").to_matchable(),
                Ref::keyword("AZ64").to_matchable(),
                Ref::keyword("BYTEDICT").to_matchable(),
                Ref::keyword("DELTA").to_matchable(),
                Ref::keyword("DELTA32K").to_matchable(),
                Ref::keyword("LZO").to_matchable(),
                Ref::keyword("MOSTLY8").to_matchable(),
                Ref::keyword("MOSTLY16").to_matchable(),
                Ref::keyword("MOSTLY32").to_matchable(),
                Ref::keyword("RUNLENGTH").to_matchable(),
                Ref::keyword("TEXT255").to_matchable(),
                Ref::keyword("TEXT32K").to_matchable(),
                Ref::keyword("ZSTD").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "QuotaGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("QUOTA").to_matchable(),
                one_of(vec![
                    Sequence::new(vec![
                        Ref::new("NumericLiteralSegment").to_matchable(),
                        one_of(vec![
                            Ref::keyword("MB").to_matchable(),
                            Ref::keyword("GB").to_matchable(),
                            Ref::keyword("TB").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("UNLIMITED").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "MaxLiteralSegment".into(),
            StringParser::new("max", SyntaxKind::MaxLiteral)
                .to_matchable()
                .into(),
        ),
    ]);

    redshift_dialect.add([
        (
            "FromIntegrationClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::FromIntegrationClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("FROM").to_matchable(),
                    Ref::keyword("INTEGRATION").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("DATABASE").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::keyword("SET").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ACCEPTINVCHARS").to_matchable(),
                            Ref::new("EqualsSegment").optional().to_matchable(),
                            Ref::new("BooleanLiteralGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("QUERY_ALL_STATES").to_matchable(),
                            Ref::new("EqualsSegment").optional().to_matchable(),
                            Ref::new("BooleanLiteralGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REFRESH_INTERVAL").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("TRUNCATECOLUMNS").to_matchable(),
                            Ref::new("EqualsSegment").optional().to_matchable(),
                            Ref::new("BooleanLiteralGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("HISTORY_MODE").to_matchable(),
                            Ref::new("EqualsSegment").optional().to_matchable(),
                            Ref::new("BooleanLiteralGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IamRoleClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::IamRoleClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("IAM_ROLE").to_matchable(),
                    one_of(vec![
                        Ref::keyword("DEFAULT").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IsolationLevelClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::IsolationLevelClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ISOLATION").to_matchable(),
                    Ref::keyword("LEVEL").to_matchable(),
                    one_of(vec![
                        Ref::keyword("SERIALIZABLE").to_matchable(),
                        Ref::keyword("SNAPSHOT").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CollationClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::CollationClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("COLLATE").to_matchable(),
                    one_of(vec![
                        Ref::keyword("CASE_SENSITIVE").to_matchable(),
                        Ref::keyword("CS").to_matchable(),
                        Ref::keyword("CASE_INSENSITIVE").to_matchable(),
                        Ref::keyword("CI").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ConnectionLimitSegment".into(),
            NodeMatcher::new(SyntaxKind::ConnectionLimitSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CONNECTION").to_matchable(),
                    Ref::keyword("LIMIT").to_matchable(),
                    one_of(vec![
                        Ref::new("NumericLiteralSegment").to_matchable(),
                        Ref::keyword("UNLIMITED").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateDatabaseWithOptionsSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateDatabaseWithOptions, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("OWNER").to_matchable(),
                        Ref::new("EqualsSegment").optional().to_matchable(),
                        Ref::new("RoleReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("ConnectionLimitSegment").to_matchable(),
                    Ref::new("CollationClauseSegment").to_matchable(),
                    Ref::new("IsolationLevelClauseSegment").to_matchable(),
                ])
                .config(|this| {
                    this.max_times_per_element = Some(1);
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromDatashareClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::FromDatashareClause, |_dialect| {
                Sequence::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Ref::keyword("PERMISSIONS").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("FROM").to_matchable(),
                    Ref::keyword("DATASHARE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Ref::keyword("OF").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ACCOUNT").to_matchable(),
                        one_of(vec![
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            Ref::new("ObjectReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("NAMESPACE").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("ObjectReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArnCatalogSchemaSegment".into(),
            NodeMatcher::new(SyntaxKind::ArnCatalogSchemaSegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("FROM").to_matchable(),
                    Ref::keyword("ARN").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("WITH").to_matchable(),
                            Ref::keyword("DATA").to_matchable(),
                            Ref::keyword("CATALOG").to_matchable(),
                            Ref::keyword("SCHEMA").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("WITH").to_matchable(),
                            Ref::keyword("NO").to_matchable(),
                            Ref::keyword("DATA").to_matchable(),
                            Ref::keyword("CATALOG").to_matchable(),
                            Ref::keyword("SCHEMA").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateDatabaseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateDatabaseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("DATABASE").to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("FromIntegrationClauseSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("WITH").to_matchable(),
                            Ref::new("CreateDatabaseWithOptionsSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ArnCatalogSchemaSegment").to_matchable(),
                        Ref::new("IamRoleClauseSegment").to_matchable(),
                        Ref::new("FromDatashareClauseSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromUnpivotExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::FromUnpivotExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UNPIVOT").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("INCLUDE").to_matchable(),
                            Ref::keyword("EXCLUDE").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("NULLS").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Bracketed::new(vec![
                        Sequence::new(vec![
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::keyword("FOR").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::keyword("IN").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Sequence::new(vec![
                                        Ref::new("ColumnReferenceSegment").to_matchable(),
                                        Ref::new("AliasExpressionSegment")
                                            .optional()
                                            .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromPivotExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::FromPivotExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("PIVOT").to_matchable(),
                    Bracketed::new(vec![
                        Sequence::new(vec![
                            optionally_bracketed(vec![Ref::new("FunctionSegment").to_matchable()])
                                .to_matchable(),
                            Ref::new("AliasExpressionSegment").optional().to_matchable(),
                            Ref::keyword("FOR").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::keyword("IN").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Sequence::new(vec![
                                        Ref::new("ExpressionSegment").to_matchable(),
                                        Ref::new("AliasExpressionSegment")
                                            .optional()
                                            .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DateTimeTypeIdentifier".into(),
            NodeMatcher::new(SyntaxKind::DatetimeTypeIdentifier, |_dialect| {
                one_of(vec![
                    Ref::keyword("DATE").to_matchable(),
                    Ref::keyword("DATETIME").to_matchable(),
                    Ref::new("TimeWithTZGrammar").to_matchable(),
                    one_of(vec![
                        Ref::keyword("TIMETZ").to_matchable(),
                        Ref::keyword("TIMESTAMPTZ").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "BracketedArguments".into(),
            NodeMatcher::new(SyntaxKind::BracketedArguments, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        one_of(vec![
                            Ref::new("LiteralGrammar").to_matchable(),
                            Ref::keyword("MAX").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DatatypeSegment".into(),
            NodeMatcher::new(SyntaxKind::DataType, |_dialect| {
                one_of(vec![
                    Ref::keyword("SMALLINT").to_matchable(),
                    Ref::keyword("INT2").to_matchable(),
                    Ref::keyword("INTEGER").to_matchable(),
                    Ref::keyword("INT").to_matchable(),
                    Ref::keyword("INT4").to_matchable(),
                    Ref::keyword("BIGINT").to_matchable(),
                    Ref::keyword("INT8").to_matchable(),
                    Ref::keyword("REAL").to_matchable(),
                    Ref::keyword("FLOAT4").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("DOUBLE").to_matchable(),
                        Ref::keyword("PRECISION").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("FLOAT8").to_matchable(),
                    Ref::keyword("FLOAT").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("DECIMAL").to_matchable(),
                            Ref::keyword("NUMERIC").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("BracketedArguments").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("CHAR").to_matchable(),
                                Ref::keyword("CHARACTER").to_matchable(),
                                Ref::keyword("NCHAR").to_matchable(),
                                Ref::keyword("VARCHAR").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("CHARACTER").to_matchable(),
                                    Ref::keyword("VARYING").to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::keyword("NVARCHAR").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("BracketedArguments").optional().to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("BPCHAR").to_matchable(),
                        Ref::keyword("TEXT").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DateTimeTypeIdentifier").to_matchable(),
                    Ref::keyword("INTERVAL").to_matchable(),
                    one_of(vec![
                        Ref::keyword("BOOLEAN").to_matchable(),
                        Ref::keyword("BOOL").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("HLLSKETCH").to_matchable(),
                    Ref::keyword("SUPER").to_matchable(),
                    Ref::keyword("GEOMETRY").to_matchable(),
                    Ref::keyword("GEOGRAPHY").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("VARBYTE").to_matchable(),
                            Ref::keyword("VARBINARY").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("BINARY").to_matchable(),
                                Ref::keyword("VARYING").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("BracketedArguments").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("ANYELEMENT").to_matchable(),
                    Sequence::new(vec![
                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                        Ref::new("DotSegment").to_matchable(),
                        Ref::new("DatatypeIdentifierSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.disallow_gaps();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DataFormatSegment".into(),
            NodeMatcher::new(SyntaxKind::DataFormatSegment, |_dialect| {
                Sequence::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("FORMAT").to_matchable(),
                        Ref::keyword("AS").optional().to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("CSV").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("QUOTE").to_matchable(),
                                Ref::keyword("AS").optional().to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SHAPEFILE").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("SIMPLIFY").to_matchable(),
                                Ref::keyword("AUTO").optional().to_matchable(),
                                Ref::new("NumericLiteralSegment").optional().to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("AVRO").to_matchable(),
                                Ref::keyword("JSON").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("AS").optional().to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("PARQUET").to_matchable(),
                        Ref::keyword("ORC").to_matchable(),
                        Ref::keyword("RCFILE").to_matchable(),
                        Ref::keyword("SEQUENCEFILE").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AuthorizationSegment".into(),
            NodeMatcher::new(SyntaxKind::AuthorizationSegment, |_dialect| {
                AnyNumberOf::new(vec![
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("IAM_ROLE").to_matchable(),
                            one_of(vec![
                                Ref::keyword("DEFAULT").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("WITH").optional().to_matchable(),
                            Ref::keyword("CREDENTIALS").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ACCESS_KEY_ID").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Ref::keyword("SECRET_ACCESS_KEY").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("SESSION_TOKEN").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("KMS_KEY_ID").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("MASTER_SYMMETRIC_KEY").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .config(|this| {
                    this.max_times_per_element = Some(1);
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnAttributeSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnAttributeSegment, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("DEFAULT").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("IDENTITY").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("NumericLiteralSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("GENERATED").to_matchable(),
                        Ref::keyword("BY").to_matchable(),
                        Ref::keyword("DEFAULT").to_matchable(),
                        Ref::keyword("AS").to_matchable(),
                        Ref::keyword("IDENTITY").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("NumericLiteralSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ENCODE").to_matchable(),
                        Ref::new("ColumnEncodingGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("DISTKEY").to_matchable(),
                    Ref::keyword("SORTKEY").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("COLLATE").to_matchable(),
                        one_of(vec![
                            Ref::keyword("CASE_SENSITIVE").to_matchable(),
                            Ref::keyword("CASE_INSENSITIVE").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.max_times_per_element = Some(1);
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnConstraintSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnConstraintSegment, |_dialect| {
                AnyNumberOf::new(vec![
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("NOT").to_matchable(),
                            Ref::keyword("NULL").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("NULL").to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Ref::keyword("UNIQUE").to_matchable(),
                        Ref::new("PrimaryKeyGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("REFERENCES").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                        Bracketed::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.max_times_per_element = Some(1);
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterTableActionSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterTableActionSegment, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::keyword("ADD").to_matchable(),
                        Ref::new("TableConstraintSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("NOT").to_matchable(),
                            Ref::keyword("VALID").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("VALIDATE").to_matchable(),
                        Ref::keyword("CONSTRAINT").to_matchable(),
                        Ref::new("ParameterNameSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("DROP").to_matchable(),
                        Ref::keyword("CONSTRAINT").to_matchable(),
                        Ref::new("ParameterNameSegment").to_matchable(),
                        Ref::new("DropBehaviorGrammar").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("OWNER").to_matchable(),
                        Ref::keyword("TO").to_matchable(),
                        one_of(vec![
                            one_of(vec![
                                Ref::new("ParameterNameSegment").to_matchable(),
                                Ref::new("QuotedIdentifierSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("RENAME").to_matchable(),
                        Ref::keyword("TO").to_matchable(),
                        one_of(vec![
                            one_of(vec![
                                Ref::new("ParameterNameSegment").to_matchable(),
                                Ref::new("QuotedIdentifierSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("RENAME").to_matchable(),
                        Ref::keyword("COLUMN").to_matchable(),
                        Ref::keyword("TO").to_matchable(),
                        one_of(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ALTER").to_matchable(),
                        Ref::keyword("COLUMN").optional().to_matchable(),
                        Ref::new("ColumnReferenceSegment").to_matchable(),
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("TYPE").to_matchable(),
                                Ref::new("DatatypeSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("ENCODE").to_matchable(),
                                Delimited::new(vec![
                                    Ref::new("ColumnEncodingGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ALTER").to_matchable(),
                        Ref::keyword("DISTKEY").to_matchable(),
                        Ref::new("ColumnReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ALTER").to_matchable(),
                        Ref::keyword("DISTSTYLE").to_matchable(),
                        one_of(vec![
                            Ref::keyword("ALL").to_matchable(),
                            Ref::keyword("EVEN").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("KEY").to_matchable(),
                                Ref::keyword("DISTKEY").to_matchable(),
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("AUTO").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ALTER").to_matchable(),
                        Ref::keyword("COMPOUND").optional().to_matchable(),
                        Ref::keyword("SORTKEY").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ALTER").to_matchable(),
                        Ref::keyword("SORTKEY").to_matchable(),
                        one_of(vec![
                            Ref::keyword("AUTO").to_matchable(),
                            Ref::keyword("NONE").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ALTER").to_matchable(),
                        Ref::keyword("ENCODE").to_matchable(),
                        Ref::keyword("AUTO").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ADD").to_matchable(),
                        Ref::keyword("COLUMN").optional().to_matchable(),
                        Ref::new("ColumnReferenceSegment").to_matchable(),
                        Ref::new("DatatypeSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DEFAULT").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ENCODE").to_matchable(),
                            Ref::new("ColumnEncodingGrammar").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("COLLATE").to_matchable(),
                            Ref::new("CollationReferenceSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        AnyNumberOf::new(vec![Ref::new("ColumnConstraintSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("DROP").to_matchable(),
                        Ref::keyword("COLUMN").optional().to_matchable(),
                        Ref::new("ColumnReferenceSegment").to_matchable(),
                        Ref::new("DropBehaviorGrammar").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("APPEND").to_matchable(),
                        Ref::keyword("FROM").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                        Ref::keyword("IGNOREEXTRA").optional().to_matchable(),
                        Ref::keyword("FILLTARGET").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("SET").to_matchable(),
                        Ref::keyword("LOCATION").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableAttributeSegment".into(),
            NodeMatcher::new(SyntaxKind::TableConstraint, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("DISTSTYLE").to_matchable(),
                        one_of(vec![
                            Ref::keyword("AUTO").to_matchable(),
                            Ref::keyword("EVEN").to_matchable(),
                            Ref::keyword("KEY").to_matchable(),
                            Ref::keyword("ALL").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("DISTKEY").to_matchable(),
                        Bracketed::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("COMPOUND").to_matchable(),
                                Ref::keyword("INTERLEAVED").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Ref::keyword("SORTKEY").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SORTKEY").to_matchable(),
                            Ref::keyword("AUTO").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ENCODE").to_matchable(),
                        Ref::keyword("AUTO").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .config(|this| {
                    this.max_times_per_element = Some(1);
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableConstraintSegment".into(),
            NodeMatcher::new(SyntaxKind::TableConstraint, |_dialect| {
                Sequence::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("CONSTRAINT").to_matchable(),
                        Ref::new("ObjectReferenceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("UNIQUE").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("PRIMARY").to_matchable(),
                            Ref::keyword("KEY").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("FOREIGN").to_matchable(),
                            Ref::keyword("KEY").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("REFERENCES").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LikeOptionSegment".into(),
            NodeMatcher::new(SyntaxKind::LikeOptionSegment, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("INCLUDING").to_matchable(),
                        Ref::keyword("EXCLUDING").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("DEFAULTS").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("LOCAL").optional().to_matchable(),
                    Ref::new("TemporaryGrammar").optional().to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                    AnyNumberOf::new(vec![
                                        Ref::new("ColumnAttributeSegment").to_matchable(),
                                        Ref::new("ColumnConstraintSegment").to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("TableConstraintSegment").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("LIKE").to_matchable(),
                                    Ref::new("TableReferenceSegment").to_matchable(),
                                    AnyNumberOf::new(vec![
                                        Ref::new("LikeOptionSegment").to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("BACKUP").to_matchable(),
                        one_of(vec![
                            Ref::keyword("YES").to_matchable(),
                            Ref::keyword("NO").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    AnyNumberOf::new(vec![Ref::new("TableAttributeSegment").to_matchable()])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTableAsStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTableAsStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("LOCAL").optional().to_matchable(),
                        one_of(vec![
                            Ref::keyword("TEMPORARY").to_matchable(),
                            Ref::keyword("TEMP").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("BACKUP").to_matchable(),
                        one_of(vec![
                            Ref::keyword("YES").to_matchable(),
                            Ref::keyword("NO").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("TableAttributeSegment").optional().to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateModelStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateModelStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("MODEL").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("FROM").to_matchable(),
                        one_of(vec![
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Bracketed::new(vec![Ref::new("SelectableGrammar").to_matchable()])
                                .to_matchable(),
                            Ref::new("ObjectReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("TARGET").to_matchable(),
                        Ref::new("ColumnReferenceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("FUNCTION").to_matchable(),
                        Ref::new("ObjectReferenceSegment").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("DatatypeSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("RETURNS").to_matchable(),
                        Ref::new("DatatypeSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("SAGEMAKER").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("IAM_ROLE").to_matchable(),
                        one_of(vec![
                            Ref::keyword("DEFAULT").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AUTO").to_matchable(),
                        one_of(vec![
                            Ref::keyword("ON").to_matchable(),
                            Ref::keyword("OFF").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("MODEL_TYPE").to_matchable(),
                        one_of(vec![
                            Ref::keyword("XGBOOST").to_matchable(),
                            Ref::keyword("MLP").to_matchable(),
                            Ref::keyword("KMEANS").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("PROBLEM_TYPE").to_matchable(),
                        one_of(vec![
                            Ref::keyword("REGRESSION").to_matchable(),
                            Ref::keyword("BINARY_CLASSIFICATION").to_matchable(),
                            Ref::keyword("MULTICLASS_CLASSIFICATION").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("OBJECTIVE").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("PREPROCESSORS").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("HYPERPARAMETERS").to_matchable(),
                        Ref::keyword("DEFAULT").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("EXCEPT").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![Anything::new().to_matchable()]).to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("SETTINGS").to_matchable(),
                        Bracketed::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("S3_BUCKET").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("KMS_KEY_ID").to_matchable(),
                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("S3_GARBAGE_COLLECT").to_matchable(),
                                    one_of(vec![
                                        Ref::keyword("ON").to_matchable(),
                                        Ref::keyword("OFF").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("MAX_CELLS").to_matchable(),
                                    Ref::new("NumericLiteralSegment").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("MAX_RUNTIME").to_matchable(),
                                    Ref::new("NumericLiteralSegment").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ShowModelStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ShowModelStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SHOW").to_matchable(),
                    Ref::keyword("MODEL").to_matchable(),
                    one_of(vec![
                        Ref::keyword("ALL").to_matchable(),
                        Ref::new("ObjectReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateExternalTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateExternalTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("EXTERNAL").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("DatatypeSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("PartitionedBySegment").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ROW").to_matchable(),
                        Ref::keyword("FORMAT").to_matchable(),
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("DELIMITED").to_matchable(),
                                Ref::new("RowFormatDelimitedSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("SERDE").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("WITH").to_matchable(),
                                    Ref::keyword("SERDEPROPERTIES").to_matchable(),
                                    Bracketed::new(vec![
                                        Delimited::new(vec![
                                            Sequence::new(vec![
                                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                                Ref::new("EqualsSegment").to_matchable(),
                                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("STORED").to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    one_of(vec![
                        Ref::keyword("PARQUET").to_matchable(),
                        Ref::keyword("RCFILE").to_matchable(),
                        Ref::keyword("SEQUENCEFILE").to_matchable(),
                        Ref::keyword("TEXTFILE").to_matchable(),
                        Ref::keyword("ORC").to_matchable(),
                        Ref::keyword("AVRO").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("INPUTFORMAT").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Ref::keyword("OUTPUTFORMAT").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("LOCATION").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("TABLE").to_matchable(),
                        Ref::keyword("PROPERTIES").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                    Ref::new("EqualsSegment").to_matchable(),
                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateExternalTableAsStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateExternalTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("EXTERNAL").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("PartitionedBySegment").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ROW").to_matchable(),
                        Ref::keyword("FORMAT").to_matchable(),
                        Ref::keyword("DELIMITED").to_matchable(),
                        Ref::new("RowFormatDelimitedSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("STORED").to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    one_of(vec![
                        Ref::keyword("PARQUET").to_matchable(),
                        Ref::keyword("TEXTFILE").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("LOCATION").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("TABLE").to_matchable(),
                        Ref::keyword("PROPERTIES").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                    Ref::new("EqualsSegment").to_matchable(),
                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateExternalSchemaStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateExternalSchemaStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("EXTERNAL").to_matchable(),
                    Ref::keyword("SCHEMA").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("SchemaReferenceSegment").to_matchable(),
                    Ref::keyword("FROM").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("DATA").to_matchable(),
                            Ref::keyword("CATALOG").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("HIVE").to_matchable(),
                            Ref::keyword("METASTORE").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("POSTGRES").to_matchable(),
                        Ref::keyword("MYSQL").to_matchable(),
                        Ref::keyword("KINESIS").to_matchable(),
                        Ref::keyword("MSK").to_matchable(),
                        Ref::keyword("REDSHIFT").to_matchable(),
                        Ref::keyword("KAFKA").to_matchable(),
                    ])
                    .to_matchable(),
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::keyword("DATABASE").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REGION").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SCHEMA").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("URI").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("PORT").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("IAM_ROLE").to_matchable(),
                            one_of(vec![
                                Ref::keyword("DEFAULT").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("AUTHENTICATION").to_matchable(),
                            one_of(vec![
                                Ref::keyword("NONE").to_matchable(),
                                Ref::keyword("IAM").to_matchable(),
                                Ref::keyword("MTLS").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("AUTHENTICATION_ARN").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("SECRET_ARN").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("CATALOG_ROLE").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("CREATE").to_matchable(),
                            Ref::keyword("EXTERNAL").to_matchable(),
                            Ref::keyword("DATABASE").to_matchable(),
                            Ref::keyword("IF").to_matchable(),
                            Ref::keyword("NOT").to_matchable(),
                            Ref::keyword("EXISTS").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateLibraryStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateLibraryStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("LIBRARY").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Ref::keyword("LANGUAGE").to_matchable(),
                    Ref::keyword("PLPYTHONU").to_matchable(),
                    Ref::keyword("FROM").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("AuthorizationSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REGION").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnloadStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::UnloadStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UNLOAD").to_matchable(),
                    Bracketed::new(vec![Ref::new("QuotedLiteralSegment").to_matchable()])
                        .to_matchable(),
                    Ref::keyword("TO").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("AuthorizationSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REGION").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::new("CompressionTypeGrammar").optional().to_matchable(),
                        Sequence::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("FORMAT").to_matchable(),
                                Ref::keyword("AS").optional().to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            one_of(vec![
                                Ref::keyword("CSV").to_matchable(),
                                Ref::keyword("JSON").to_matchable(),
                                Ref::keyword("PARQUET").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("PARTITION").to_matchable(),
                            Ref::keyword("BY").to_matchable(),
                            Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                            Ref::keyword("INCLUDE").optional().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("PARALLEL").to_matchable(),
                            one_of(vec![
                                Ref::keyword("PRESET").to_matchable(),
                                Ref::keyword("ON").to_matchable(),
                                Ref::keyword("OFF").to_matchable(),
                                Ref::keyword("TRUE").to_matchable(),
                                Ref::keyword("FALSE").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("EXTENSION").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("PARALLEL").to_matchable(),
                                one_of(vec![
                                    Ref::keyword("ON").to_matchable(),
                                    Ref::keyword("OFF").to_matchable(),
                                    Ref::keyword("TRUE").to_matchable(),
                                    Ref::keyword("FALSE").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("DELIMITER").to_matchable(),
                                Ref::keyword("AS").optional().to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("FIXEDWIDTH").to_matchable(),
                                Ref::keyword("AS").optional().to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("MANIFEST").to_matchable(),
                            Ref::keyword("VERBOSE").optional().to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("NULL").to_matchable(),
                            Ref::keyword("AS").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("NULL").to_matchable(),
                            Ref::keyword("AS").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        AnyNumberOf::new(vec![
                            one_of(vec![
                                Ref::keyword("MAXFILESIZE").to_matchable(),
                                Ref::keyword("ROWGROUPSIZE").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            one_of(vec![
                                Ref::keyword("MB").to_matchable(),
                                Ref::keyword("GB").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.max_times_per_element = Some(1);
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ENCRYPTED").to_matchable(),
                            Ref::keyword("AUTO").optional().to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("ALLOWOVERWRITE").optional().to_matchable(),
                        Ref::keyword("CLEANPATH").optional().to_matchable(),
                        Ref::keyword("ESCAPE").optional().to_matchable(),
                        Ref::keyword("ADDQUOTES").optional().to_matchable(),
                        Ref::keyword("HEADER").optional().to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CopyStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CopyStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("COPY").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("BracketedColumnReferenceListGrammar")
                        .optional()
                        .to_matchable(),
                    Ref::keyword("FROM").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("AuthorizationSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REGION").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::new("CompressionTypeGrammar").optional().to_matchable(),
                        Ref::new("DataFormatSegment").optional().to_matchable(),
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("DELIMITER").to_matchable(),
                                Ref::keyword("AS").optional().to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("FIXEDWIDTH").to_matchable(),
                                Ref::keyword("AS").optional().to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ENCRYPTED").to_matchable(),
                            Ref::keyword("AUTO").optional().to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("MANIFEST").optional().to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("COMPROWS").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("MAXERROR").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("COMPUPDATE").to_matchable(),
                            one_of(vec![
                                Ref::keyword("PRESET").to_matchable(),
                                Ref::keyword("ON").to_matchable(),
                                Ref::keyword("OFF").to_matchable(),
                                Ref::keyword("TRUE").to_matchable(),
                                Ref::keyword("FALSE").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("STATUPDATE").to_matchable(),
                            one_of(vec![
                                Ref::keyword("ON").to_matchable(),
                                Ref::keyword("OFF").to_matchable(),
                                Ref::keyword("TRUE").to_matchable(),
                                Ref::keyword("FALSE").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("NOLOAD").optional().to_matchable(),
                        Ref::keyword("ACCEPTANYDATE").optional().to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ACCEPTINVCHARS").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("QuotedLiteralSegment").optional().to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("BLANKSASNULL").optional().to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DATEFORMAT").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            one_of(vec![
                                Ref::keyword("AUTO").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("EMPTYASNULL").optional().to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ENCODING").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            one_of(vec![
                                Ref::keyword("UTF8").to_matchable(),
                                Ref::keyword("UTF16").to_matchable(),
                                Ref::keyword("UTF16BE").to_matchable(),
                                Ref::keyword("UTF16LE").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("ESCAPE").optional().to_matchable(),
                        Ref::keyword("EXPLICIT_IDS").optional().to_matchable(),
                        Ref::keyword("FILLRECORD").optional().to_matchable(),
                        Ref::keyword("IGNOREBLANKLINES").optional().to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("IGNOREHEADER").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("LiteralGrammar").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("NULL").to_matchable(),
                            Ref::keyword("AS").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("READRATIO").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("REMOVEQUOTES").optional().to_matchable(),
                        Ref::keyword("ROUNDEC").optional().to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("TIMEFORMAT").to_matchable(),
                            Ref::keyword("AS").optional().to_matchable(),
                            one_of(vec![
                                Ref::keyword("AUTO").to_matchable(),
                                Ref::keyword("EPOCHSECS").to_matchable(),
                                Ref::keyword("EPOCHMILLISECS").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("TRIMBLANKS").optional().to_matchable(),
                        Ref::keyword("TRUNCATECOLUMNS").optional().to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "InsertStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::InsertStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INSERT").to_matchable(),
                    Ref::keyword("INTO").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                            .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DEFAULT").to_matchable(),
                            Ref::keyword("VALUES").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("BracketedColumnReferenceListGrammar")
                                .optional()
                                .to_matchable(),
                            one_of(vec![
                                Ref::new("ValuesClauseSegment").to_matchable(),
                                optionally_bracketed(vec![
                                    Ref::new("SelectableGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateSchemaStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateSchemaStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("SCHEMA").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                            Ref::new("SchemaReferenceSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("AUTHORIZATION").to_matchable(),
                                Ref::new("RoleReferenceSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("AUTHORIZATION").to_matchable(),
                            Ref::new("RoleReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("QuotaGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ProcedureParameterListSegment".into(),
            NodeMatcher::new(SyntaxKind::ProcedureParameterList, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            AnyNumberOf::new(vec![
                                Ref::new("ParameterNameSegment")
                                    .exclude(one_of(vec![
                                        one_of(vec![
                                            Ref::keyword("REFCURSOR").to_matchable(),
                                            Ref::new("DatatypeSegment").to_matchable(),
                                        ])
                                        .to_matchable(),
                                        Ref::new("ArgModeGrammar").to_matchable(),
                                    ]))
                                    .optional()
                                    .to_matchable(),
                                Ref::new("ArgModeGrammar").optional().to_matchable(),
                            ])
                            .to_matchable(),
                            one_of(vec![
                                Ref::keyword("REFCURSOR").to_matchable(),
                                Ref::new("DatatypeSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateProcedureStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateProcedureStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("PROCEDURE").to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                    Ref::new("ProcedureParameterListSegment").to_matchable(),
                    Ref::keyword("NONATOMIC").optional().to_matchable(),
                    Ref::new("FunctionDefinitionGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterProcedureStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterProcedureStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("PROCEDURE").to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                    Ref::new("ProcedureParameterListSegment")
                        .optional()
                        .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("FunctionNameSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("OWNER").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            one_of(vec![
                                one_of(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("QuotedIdentifierSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::keyword("CURRENT_USER").to_matchable(),
                                Ref::keyword("SESSION_USER").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropProcedureStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropProcedureStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("PROCEDURE").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("FunctionNameSegment").to_matchable(),
                            Ref::new("ProcedureParameterListSegment")
                                .optional()
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterDefaultPrivilegesSchemaObjectsSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterDefaultPrivilegesSchemaObject, |_dialect| {
                {
                    let dialect = super::postgres::raw_dialect();
                    dialect
                        .grammar("AlterDefaultPrivilegesSchemaObjectsSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Sequence::new(vec![Ref::keyword("PROCEDURES").to_matchable()])
                            .to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "DeclareStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DeclareStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DECLARE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Ref::keyword("CURSOR").to_matchable(),
                    Ref::keyword("FOR").to_matchable(),
                    Ref::new("SelectableGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FetchStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::FetchStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("FETCH").to_matchable(),
                    one_of(vec![
                        Ref::keyword("NEXT").to_matchable(),
                        Ref::keyword("ALL").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("FORWARD").to_matchable(),
                            one_of(vec![
                                Ref::keyword("ALL").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("FROM").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CloseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CloseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CLOSE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AltereDatashareStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateDatashareStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("DATASHARE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("ADD").to_matchable(),
                                Ref::keyword("REMOVE").to_matchable(),
                            ])
                            .to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("TABLE").to_matchable(),
                                    Delimited::new(vec![
                                        Ref::new("TableReferenceSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("SCHEMA").to_matchable(),
                                    Delimited::new(vec![
                                        Ref::new("SchemaReferenceSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("FUNCTION").to_matchable(),
                                    Delimited::new(vec![
                                        Ref::new("FunctionNameSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("ALL").to_matchable(),
                                    one_of(vec![
                                        Ref::keyword("TABLES").to_matchable(),
                                        Ref::keyword("FUNCTIONS").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::keyword("IN").to_matchable(),
                                    Ref::keyword("SCHEMA").to_matchable(),
                                    Delimited::new(vec![
                                        Ref::new("SchemaReferenceSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("PUBLICACCESSIBLE").to_matchable(),
                                    Ref::new("EqualsSegment").optional().to_matchable(),
                                    Ref::new("BooleanLiteralGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("INCLUDENEW").to_matchable(),
                                    Ref::new("EqualsSegment").optional().to_matchable(),
                                    Ref::new("BooleanLiteralGrammar").to_matchable(),
                                    Ref::keyword("FOR").to_matchable(),
                                    Ref::keyword("SCHEMA").to_matchable(),
                                    Ref::new("SchemaReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateDatashareStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateDatashareStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("DATASHARE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("SET").optional().to_matchable(),
                        Ref::keyword("PUBLICACCESSIBLE").to_matchable(),
                        Ref::new("EqualsSegment").optional().to_matchable(),
                        one_of(vec![
                            Ref::keyword("TRUE").to_matchable(),
                            Ref::keyword("FALSE").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DescDatashareStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DescDatashareStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DESC").to_matchable(),
                    Ref::keyword("DATASHARE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("OF").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ACCOUNT").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("NAMESPACE").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropDatashareStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropDatashareStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("DATASHARE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ShowDatasharesStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ShowDatasharesStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SHOW").to_matchable(),
                    Ref::keyword("DATASHARES").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("LIKE").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "GrantUsageDatashareStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::GrantDatashareStatement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("GRANT").to_matchable(),
                        Ref::keyword("REVOKE").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("USAGE").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Ref::keyword("DATASHARE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    one_of(vec![
                        Ref::keyword("TO").to_matchable(),
                        Ref::keyword("FROM").to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("NAMESPACE").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ACCOUNT").to_matchable(),
                            Sequence::new(vec![
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("VIA").to_matchable(),
                                    Ref::keyword("DATA").to_matchable(),
                                    Ref::keyword("CATALOG").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateRlsPolicyStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateRlsPolicyStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("RLS").to_matchable(),
                    Ref::keyword("POLICY").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("AS").optional().to_matchable(),
                            Ref::new("AliasExpressionSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("USING").to_matchable(),
                        Bracketed::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ManageRlsPolicyStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ManageRlsPolicyStatement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("ATTACH").to_matchable(),
                        Ref::keyword("DETACH").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("RLS").to_matchable(),
                    Ref::keyword("POLICY").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Ref::keyword("TABLE").optional().to_matchable(),
                    Delimited::new(vec![Ref::new("TableReferenceSegment").to_matchable()])
                        .to_matchable(),
                    one_of(vec![
                        Ref::keyword("TO").to_matchable(),
                        Ref::keyword("FROM").to_matchable(),
                    ])
                    .to_matchable(),
                    Delimited::new(vec![
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("ROLE").optional().to_matchable(),
                                Ref::new("RoleReferenceSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("PUBLIC").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropRlsPolicyStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropRlsPolicyStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::keyword("RLS").to_matchable(),
                    Ref::keyword("POLICY").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    one_of(vec![
                        Ref::keyword("CASCADE").to_matchable(),
                        Ref::keyword("RESTRICT").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AnalyzeCompressionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AnalyzeCompressionStatement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("ANALYZE").to_matchable(),
                        Ref::keyword("ANALYSE").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("COMPRESSION").to_matchable(),
                    Sequence::new(vec![
                        Ref::new("TableReferenceSegment").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("COMPROWS").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "VacuumStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::VacuumStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("VACUUM").to_matchable(),
                    one_of(vec![
                        Ref::keyword("FULL").to_matchable(),
                        Ref::keyword("REINDEX").to_matchable(),
                        Ref::keyword("RECLUSTER").to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("SORT").to_matchable(),
                                Ref::keyword("DELETE").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("ONLY").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("TableReferenceSegment").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("TO").to_matchable(),
                        Ref::new("NumericLiteralSegment").to_matchable(),
                        Ref::keyword("PERCENT").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("BOOST").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StatementSegment".into(),
            NodeMatcher::new(SyntaxKind::Statement, |_dialect| {
                {
                    let dialect = super::postgres::raw_dialect();
                    dialect
                        .grammar("StatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("CreateLibraryStatementSegment").to_matchable(),
                        Ref::new("CreateGroupStatementSegment").to_matchable(),
                        Ref::new("AlterUserStatementSegment").to_matchable(),
                        Ref::new("AlterGroupStatementSegment").to_matchable(),
                        Ref::new("CreateExternalTableAsStatementSegment").to_matchable(),
                        Ref::new("CreateExternalTableStatementSegment").to_matchable(),
                        Ref::new("CreateExternalSchemaStatementSegment").to_matchable(),
                        Ref::new("DataFormatSegment").to_matchable(),
                        Ref::new("UnloadStatementSegment").to_matchable(),
                        Ref::new("CopyStatementSegment").to_matchable(),
                        Ref::new("ShowModelStatementSegment").to_matchable(),
                        Ref::new("CreateDatashareStatementSegment").to_matchable(),
                        Ref::new("DescDatashareStatementSegment").to_matchable(),
                        Ref::new("DropDatashareStatementSegment").to_matchable(),
                        Ref::new("ShowDatasharesStatementSegment").to_matchable(),
                        Ref::new("AltereDatashareStatementSegment").to_matchable(),
                        Ref::new("DeclareStatementSegment").to_matchable(),
                        Ref::new("FetchStatementSegment").to_matchable(),
                        Ref::new("CloseStatementSegment").to_matchable(),
                        Ref::new("AnalyzeCompressionStatementSegment").to_matchable(),
                        Ref::new("AlterProcedureStatementSegment").to_matchable(),
                        Ref::new("CallStatementSegment").to_matchable(),
                        Ref::new("CreateRlsPolicyStatementSegment").to_matchable(),
                        Ref::new("ManageRlsPolicyStatementSegment").to_matchable(),
                        Ref::new("DropRlsPolicyStatementSegment").to_matchable(),
                        Ref::new("CreateExternalFunctionStatementSegment").to_matchable(),
                        Ref::new("GrantUsageDatashareStatementSegment").to_matchable(),
                    ]),
                    None,
                    None,
                    Some(vec![Ref::new("ShowStatementSegment").to_matchable()]),
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "PartitionedBySegment".into(),
            NodeMatcher::new(SyntaxKind::PartitionedBySegment, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("PARTITIONED").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("DatatypeSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RowFormatDelimitedSegment".into(),
            NodeMatcher::new(SyntaxKind::RowFormatDelimitedSegment, |_dialect| {
                AnyNumberOf::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("FIELDS").to_matchable(),
                        Ref::keyword("TERMINATED").to_matchable(),
                        Ref::keyword("BY").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("LINES").to_matchable(),
                        Ref::keyword("TERMINATED").to_matchable(),
                        Ref::keyword("BY").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.max_times_per_element = Some(1);
                    this.optional();
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateUserStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateUserStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("USER").to_matchable(),
                    Ref::new("RoleReferenceSegment").to_matchable(),
                    Ref::keyword("WITH").optional().to_matchable(),
                    Ref::keyword("PASSWORD").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::keyword("DISABLE").to_matchable(),
                    ])
                    .to_matchable(),
                    AnyNumberOf::new(vec![
                        one_of(vec![
                            Ref::keyword("CREATEDB").to_matchable(),
                            Ref::keyword("NOCREATEDB").to_matchable(),
                        ])
                        .to_matchable(),
                        one_of(vec![
                            Ref::keyword("CREATEUSER").to_matchable(),
                            Ref::keyword("NOCREATEUSER").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SYSLOG").to_matchable(),
                            Ref::keyword("ACCESS").to_matchable(),
                            one_of(vec![
                                Ref::keyword("RESTRICTED").to_matchable(),
                                Ref::keyword("UNRESTRICTED").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("IN").to_matchable(),
                            Ref::keyword("GROUP").to_matchable(),
                            Delimited::new(vec![Ref::new("ObjectReferenceSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("VALID").to_matchable(),
                            Ref::keyword("UNTIL").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ConnectionLimitSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SESSION").to_matchable(),
                            Ref::keyword("TIMEOUT").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateGroupStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateGroup, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("GROUP").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").optional().to_matchable(),
                        Ref::keyword("USER").to_matchable(),
                        Delimited::new(vec![Ref::new("ObjectReferenceSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterUserStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterUserStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("USER").to_matchable(),
                    Ref::new("RoleReferenceSegment").to_matchable(),
                    Ref::keyword("WITH").optional().to_matchable(),
                    AnyNumberOf::new(vec![
                        one_of(vec![
                            Ref::keyword("CREATEDB").to_matchable(),
                            Ref::keyword("NOCREATEDB").to_matchable(),
                        ])
                        .to_matchable(),
                        one_of(vec![
                            Ref::keyword("CREATEUSER").to_matchable(),
                            Ref::keyword("NOCREATEUSER").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SYSLOG").to_matchable(),
                            Ref::keyword("ACCESS").to_matchable(),
                            one_of(vec![
                                Ref::keyword("RESTRICTED").to_matchable(),
                                Ref::keyword("UNRESTRICTED").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("PASSWORD").to_matchable(),
                            one_of(vec![
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                Ref::keyword("DISABLE").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("VALID").to_matchable(),
                                Ref::keyword("UNTIL").to_matchable(),
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("ObjectReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ConnectionLimitSegment").to_matchable(),
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("SESSION").to_matchable(),
                                Ref::keyword("TIMEOUT").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("RESET").to_matchable(),
                                Ref::keyword("SESSION").to_matchable(),
                                Ref::keyword("TIMEOUT").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("SET").to_matchable(),
                                Ref::new("ObjectReferenceSegment").to_matchable(),
                                one_of(vec![
                                    Ref::keyword("TO").to_matchable(),
                                    Ref::new("EqualsSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                one_of(vec![
                                    Ref::keyword("DEFAULT").to_matchable(),
                                    Ref::new("LiteralGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("RESET").to_matchable(),
                                Ref::new("ObjectReferenceSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                        this.min_times(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterGroupStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterGroup, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("GROUP").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("ADD").to_matchable(),
                                Ref::keyword("DROP").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("USER").to_matchable(),
                            Delimited::new(vec![Ref::new("ObjectReferenceSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("ObjectReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TransactionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::TransactionStatement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("BEGIN").to_matchable(),
                        Ref::keyword("START").to_matchable(),
                        Ref::keyword("COMMIT").to_matchable(),
                        Ref::keyword("END").to_matchable(),
                        Ref::keyword("ROLLBACK").to_matchable(),
                        Ref::keyword("ABORT").to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Ref::keyword("TRANSACTION").to_matchable(),
                        Ref::keyword("WORK").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ISOLATION").to_matchable(),
                        Ref::keyword("LEVEL").to_matchable(),
                        one_of(vec![
                            Ref::keyword("SERIALIZABLE").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("READ").to_matchable(),
                                Ref::keyword("COMMITTED").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("READ").to_matchable(),
                                Ref::keyword("UNCOMMITTED").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("REPEATABLE").to_matchable(),
                                Ref::keyword("READ").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("READ").to_matchable(),
                            Ref::keyword("ONLY").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("READ").to_matchable(),
                            Ref::keyword("WRITE").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterSchemaStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterSchemaStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("SCHEMA").to_matchable(),
                    Ref::new("SchemaReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("SchemaReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("OWNER").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("RoleReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("QuotaGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LockTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::LockTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("LOCK").to_matchable(),
                    Ref::keyword("TABLE").optional().to_matchable(),
                    Delimited::new(vec![Ref::new("TableReferenceSegment").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::TableExpression, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("TableExpressionSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("ObjectUnpivotSegment").optional().to_matchable(),
                        Ref::new("ArrayUnnestSegment").optional().to_matchable(),
                    ]),
                    None,
                    Some(Ref::new("TableReferenceSegment").to_matchable()),
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "ObjectUnpivotSegment".into(),
            NodeMatcher::new(SyntaxKind::ObjectUnpivoting, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UNPIVOT").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::keyword("AT").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayAccessorSegment".into(),
            NodeMatcher::new(SyntaxKind::ArrayAccessor, |_dialect| {
                Sequence::new(vec![
                    AnyNumberOf::new(vec![
                        Bracketed::new(vec![
                            one_of(vec![
                                Ref::new("NumericLiteralSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.bracket_type("square");
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayUnnestSegment".into(),
            NodeMatcher::new(SyntaxKind::ArrayUnnesting, |_dialect| {
                Sequence::new(vec![
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::keyword("AT").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CallStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CallStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CALL").to_matchable(),
                    Ref::new("FunctionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectClauseModifierSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectClauseModifier, |_dialect| {
                {
                    let dialect = super::postgres::raw_dialect();
                    dialect
                        .grammar("SelectClauseModifierSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Sequence::new(vec![
                            Ref::keyword("TOP").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "ConvertFunctionNameSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionName, |_dialect| {
                Sequence::new(vec![Ref::keyword("CONVERT").to_matchable()]).to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FunctionSegment".into(),
            NodeMatcher::new(SyntaxKind::Function, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Sequence::new(vec![
                            Ref::new("DatePartFunctionNameSegment").to_matchable(),
                            Ref::new("DateTimeFunctionContentsSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::new("FunctionNameSegment")
                                    .exclude(one_of(vec![
                                        Ref::new("DatePartFunctionNameSegment").to_matchable(),
                                        Ref::new("ValuesClauseSegment").to_matchable(),
                                        Ref::new("ConvertFunctionNameSegment").to_matchable(),
                                    ]))
                                    .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("APPROXIMATE").to_matchable(),
                                    Ref::new("FunctionNameSegment")
                                        .exclude(one_of(vec![
                                            Ref::new("DatePartFunctionNameSegment").to_matchable(),
                                            Ref::new("ValuesClauseSegment").to_matchable(),
                                            Ref::new("ConvertFunctionNameSegment").to_matchable(),
                                        ]))
                                        .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("FunctionContentsSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("PostFunctionGrammar").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::new("ConvertFunctionNameSegment").to_matchable(),
                        Ref::new("ConvertFunctionContentsSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ConvertFunctionContentsSegment".into(),
            NodeMatcher::new(SyntaxKind::FunctionContents, |_dialect| {
                Sequence::new(vec![
                    Bracketed::new(vec![
                        Ref::new("DatatypeSegment").to_matchable(),
                        Ref::new("CommaSegment").to_matchable(),
                        Ref::new("ExpressionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::FromClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("FROM").to_matchable(),
                    Delimited::new(vec![
                        optionally_bracketed(vec![
                            Ref::new("FromExpressionSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("BracketedColumnReferenceListGrammar")
                        .optional()
                        .to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                        .to_matchable(),
                    Ref::new("WithNoSchemaBindingClauseSegment")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateMaterializedViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateMaterializedViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("MATERIALIZED").to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("BACKUP").to_matchable(),
                        one_of(vec![
                            Ref::keyword("YES").to_matchable(),
                            Ref::keyword("NO").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("TableAttributeSegment").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AUTO").to_matchable(),
                        Ref::keyword("REFRESH").to_matchable(),
                        one_of(vec![
                            Ref::keyword("YES").to_matchable(),
                            Ref::keyword("NO").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    one_of(vec![
                        optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                            .to_matchable(),
                        optionally_bracketed(vec![
                            Sequence::new(vec![
                                Ref::keyword("TABLE").to_matchable(),
                                Ref::new("TableReferenceSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ValuesClauseSegment").to_matchable(),
                        optionally_bracketed(vec![
                            Sequence::new(vec![
                                Ref::keyword("EXECUTE").to_matchable(),
                                Ref::new("FunctionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("WithDataClauseSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateExternalFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateExternalFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("EXTERNAL").to_matchable(),
                    Ref::keyword("FUNCTION").to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("DatatypeSegment").to_matchable()])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("RETURNS").to_matchable(),
                    Ref::new("DatatypeSegment").to_matchable(),
                    one_of(vec![
                        Ref::keyword("VOLATILE").to_matchable(),
                        Ref::keyword("STABLE").to_matchable(),
                        Ref::keyword("IMMUTABLE").to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Ref::keyword("LAMBDA").to_matchable(),
                        Ref::keyword("SAGEMAKER").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Ref::keyword("IAM_ROLE").to_matchable(),
                    one_of(vec![
                        Ref::keyword("DEFAULT").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("RETRY_TIMEOUT").to_matchable(),
                        Ref::new("NumericLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "QualifyClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::QualifyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("QUALIFY").to_matchable(),
                    MetaSegment::implicit_indent().to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                {
                    let dialect = super::postgres::raw_dialect();
                    dialect
                        .grammar("SelectStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("QualifyClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    Some(Ref::new("OrderByClauseSegment").optional().to_matchable()),
                    None,
                    vec![Ref::new("SetOperatorSegment").to_matchable()],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnorderedSelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("UnorderedSelectStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("QualifyClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    Some(Ref::new("OverlapsClauseSegment").optional().to_matchable()),
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "WildcardExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::WildcardExpression, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("WildcardExpressionSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("ExcludeClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "ExcludeClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectExcludeClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("EXCLUDE").to_matchable(),
                    one_of(vec![
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "GroupByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::GroupbyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("GROUP").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Delimited::new(vec![
                        one_of(vec![
                            Ref::keyword("ALL").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            Ref::new("CubeRollupClauseSegment").to_matchable(),
                            Ref::new("GroupingSetsClauseSegment").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                            Bracketed::new(vec![]).to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.terminators = vec![
                            Sequence::new(vec![
                                Ref::keyword("ORDER").to_matchable(),
                                Ref::keyword("BY").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("LIMIT").to_matchable(),
                            Ref::keyword("HAVING").to_matchable(),
                            Ref::keyword("QUALIFY").to_matchable(),
                            Ref::keyword("WINDOW").to_matchable(),
                            Ref::new("SetOperatorSegment").to_matchable(),
                        ];
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MergeStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::MergeStatement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("MergeStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        one_of(vec![
                            Ref::new("MergeMatchSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("REMOVE").to_matchable(),
                                Ref::keyword("DUPLICATES").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ]),
                    None,
                    None,
                    Some(vec![Ref::new("MergeMatchSegment").to_matchable()]),
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetOperatorSegment".into(),
            NodeMatcher::new(SyntaxKind::SetOperator, |_dialect| {
                one_of(vec![
                    Ref::new("UnionGrammar").to_matchable(),
                    Ref::keyword("INTERSECT").to_matchable(),
                    Ref::keyword("EXCEPT").to_matchable(),
                    Ref::keyword("MINUS").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PrepareStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::PrepareStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("PREPARE").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("DatatypeSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    Ref::new("SelectableGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DeallocateStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DeallocateStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DEALLOCATE").to_matchable(),
                    Ref::keyword("PREPARE").optional().to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
    ]);

    redshift_dialect
}
