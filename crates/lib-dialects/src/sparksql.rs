use sqruff_lib_core::dialects::Dialect;
use sqruff_lib_core::dialects::init::DialectKind;
use sqruff_lib_core::dialects::syntax::SyntaxKind;
use sqruff_lib_core::helpers::{Config, ToMatchable};
use sqruff_lib_core::parser::grammar::anyof::{AnyNumberOf, one_of, optionally_bracketed};
use sqruff_lib_core::parser::grammar::conditional::Conditional;
use sqruff_lib_core::parser::grammar::delimited::Delimited;
use sqruff_lib_core::parser::grammar::sequence::{Bracketed, Sequence};
use sqruff_lib_core::parser::grammar::{Anything, Ref};
use sqruff_lib_core::parser::lexer::Matcher;
use sqruff_lib_core::parser::matchable::MatchableTrait;
use sqruff_lib_core::parser::node_matcher::NodeMatcher;
use sqruff_lib_core::parser::parsers::{MultiStringParser, RegexParser, StringParser, TypedParser};
use sqruff_lib_core::parser::segments::meta::MetaSegment;
use sqruff_lib_core::parser::types::ParseMode;

use super::sparksql_keywords::{RESERVED_KEYWORDS, UNRESERVED_KEYWORDS};

pub fn dialect() -> Dialect {
    raw_dialect().config(|this| this.expand())
}

pub fn raw_dialect() -> Dialect {
    let ansi_dialect = super::ansi::raw_dialect();
    let hive_dialect = super::hive::raw_dialect();
    let mut sparksql_dialect = ansi_dialect.clone();
    sparksql_dialect.name = DialectKind::Sparksql;

    sparksql_dialect.patch_lexer_matchers(vec![
        Matcher::regex("inline_comment", r#"(--)[^\n]*"#, SyntaxKind::InlineComment),
        Matcher::regex("equals", r#"==|<=>|="#, SyntaxKind::RawComparisonOperator),
        Matcher::regex("back_quote", r#"`([^`]|``)*`"#, SyntaxKind::BackQuote),
        Matcher::legacy("numeric_literal", |_| true, r#"(?>(?>\d+\.\d+|\d+\.|\.\d+)([eE][+-]?\d+)?([dDfF]|BD|bd)?|\d+[eE][+-]?\d+([dDfF]|BD|bd)?|\d+([dDfFlLsSyY]|BD|bd)?)((?<=\.)|(?=\b))"#, SyntaxKind::NumericLiteral),
    ]);

    sparksql_dialect.insert_lexer_matchers(
        vec![
            Matcher::regex(
                "raw_single_quote",
                r#"[rR]'([^'\\]|\\.)*'"#,
                SyntaxKind::RawSingleQuote,
            ),
            Matcher::regex(
                "raw_double_quote",
                r#"[rR]"([^"\\]|\\.)*""#,
                SyntaxKind::RawDoubleQuote,
            ),
            Matcher::regex(
                "bytes_single_quote",
                r#"X'([^'\\]|\\.)*'"#,
                SyntaxKind::BytesSingleQuote,
            ),
            Matcher::regex(
                "bytes_double_quote",
                r#"X"([^"\\]|\\.)*""#,
                SyntaxKind::BytesDoubleQuote,
            ),
        ],
        "single_quote",
    );

    sparksql_dialect.insert_lexer_matchers(
        vec![Matcher::regex(
            "at_sign_literal",
            r#"@\w*"#,
            SyntaxKind::AtSignLiteral,
        )],
        "word",
    );

    sparksql_dialect.insert_lexer_matchers(vec![
        Matcher::regex("file_literal", r#"[a-zA-Z0-9]+:([a-zA-Z0-9\-_\.]*(\/|\\)){2,}((([a-zA-Z0-9\-_\.]*(:|\?|=|&)[a-zA-Z0-9\-_\.]*)+)|([a-zA-Z0-9\-_\.]*\.[a-z]+))"#, SyntaxKind::FileLiteral),
    ], "newline");

    sparksql_dialect.sets_mut("bare_functions").clear();

    sparksql_dialect.sets_mut("bare_functions").extend([
        "CURRENT_DATE",
        "CURRENT_TIMESTAMP",
        "CURRENT_USER",
    ]);

    sparksql_dialect.sets_mut("date_part_function_name").clear();

    sparksql_dialect
        .sets_mut("date_part_function_name")
        .extend([
            "DATE_ADD",
            "DATE_DIFF",
            "DATEADD",
            "DATEDIFF",
            "TIMESTAMPADD",
            "TIMESTAMPDIFF",
        ]);

    sparksql_dialect.sets_mut("datetime_units").clear();

    sparksql_dialect.sets_mut("datetime_units").extend([
        "YEAR",
        "YEARS",
        "YYYY",
        "YY",
        "QUARTER",
        "QUARTERS",
        "MONTH",
        "MONTHS",
        "MON",
        "MM",
        "WEEK",
        "WEEKS",
        "DAY",
        "DAYS",
        "DD",
        "DAYOFYEAR",
        "HOUR",
        "HOURS",
        "MINUTE",
        "MINUTES",
        "SECOND",
        "SECONDS",
        "MILLISECOND",
        "MILLISECONDS",
        "MICROSECOND",
        "MICROSECONDS",
    ]);

    sparksql_dialect
        .sets_mut("unreserved_keywords")
        .extend(UNRESERVED_KEYWORDS);

    sparksql_dialect
        .sets_mut("reserved_keywords")
        .extend(RESERVED_KEYWORDS);

    sparksql_dialect.update_bracket_sets(
        "angle_bracket_pairs",
        vec![(
            "angle",
            "StartAngleBracketSegment",
            "EndAngleBracketSegment",
            false,
        )],
    );

    sparksql_dialect.replace_grammar(
        "DateTimeLiteralGrammar",
        Sequence::new(vec![
            one_of(vec![
                Ref::keyword("DATE").to_matchable(),
                Ref::keyword("TIME").to_matchable(),
                Ref::keyword("TIMESTAMP").to_matchable(),
                Ref::keyword("INTERVAL").to_matchable(),
                Ref::keyword("TIMESTAMP_LTZ").to_matchable(),
                Ref::keyword("TIMESTAMP_NTZ").to_matchable(),
            ])
            .to_matchable(),
            TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::DateConstructorLiteral)
                .to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "ComparisonOperatorGrammar",
        one_of(vec![
            Ref::new("EqualsSegment").to_matchable(),
            Ref::new("EqualsSegment_a").to_matchable(),
            Ref::new("EqualsSegment_b").to_matchable(),
            Ref::new("GreaterThanSegment").to_matchable(),
            Ref::new("LessThanSegment").to_matchable(),
            Ref::new("GreaterThanOrEqualToSegment").to_matchable(),
            Ref::new("LessThanOrEqualToSegment").to_matchable(),
            Ref::new("NotEqualToSegment").to_matchable(),
            Ref::new("LikeOperatorSegment").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("IS").to_matchable(),
                Ref::keyword("DISTINCT").to_matchable(),
                Ref::keyword("FROM").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("IS").to_matchable(),
                Ref::keyword("NOT").to_matchable(),
                Ref::keyword("DISTINCT").to_matchable(),
                Ref::keyword("FROM").to_matchable(),
            ])
            .to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "SelectClauseTerminatorGrammar",
        ansi_dialect.grammar("SelectClauseTerminatorGrammar").copy(
            Some(vec![
                Sequence::new(vec![
                    Ref::keyword("CLUSTER").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("DISTRIBUTE").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("SORT").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                ])
                .to_matchable(),
                Ref::keyword("QUALIFY").to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    sparksql_dialect.replace_grammar(
        "FromClauseTerminatorGrammar",
        one_of(vec![
            Ref::keyword("WHERE").to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("GROUP").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("CLUSTER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("DISTRIBUTE").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("SORT").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("QUALIFY").to_matchable(),
            Ref::new("SetOperatorSegment").to_matchable(),
            Ref::new("WithNoSchemaBindingClauseSegment").to_matchable(),
            Ref::new("WithDataClauseSegment").to_matchable(),
            Ref::keyword("KEYS").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "TemporaryGrammar",
        Sequence::new(vec![
            Sequence::new(vec![Ref::keyword("GLOBAL").to_matchable()])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            one_of(vec![
                Ref::keyword("TEMP").to_matchable(),
                Ref::keyword("TEMPORARY").to_matchable(),
            ])
            .to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "QuotedLiteralSegment",
        one_of(vec![
            TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::QuotedLiteral).to_matchable(),
            TypedParser::new(SyntaxKind::DoubleQuote, SyntaxKind::QuotedLiteral).to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "LiteralGrammar",
        ansi_dialect.grammar("LiteralGrammar").copy(
            Some(vec![
                Ref::new("RawQuotedLiteralSegment").to_matchable(),
                Ref::new("BytesQuotedLiteralSegment").to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    sparksql_dialect.replace_grammar(
        "NaturalJoinKeywordsGrammar",
        Sequence::new(vec![
            Ref::keyword("NATURAL").to_matchable(),
            Ref::new("JoinTypeKeywords").optional().to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "JoinLikeClauseGrammar",
        Sequence::new(vec![
            one_of(vec![
                Ref::new("PivotClauseSegment").to_matchable(),
                Ref::new("UnpivotClauseSegment").to_matchable(),
                Ref::new("LateralViewClauseSegment").to_matchable(),
            ])
            .to_matchable(),
            Ref::new("AliasExpressionSegment")
                .exclude(one_of(vec![
                    Ref::new("FromClauseTerminatorGrammar").to_matchable(),
                    Ref::new("JoinLikeClauseGrammar").to_matchable(),
                ]))
                .optional()
                .to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "LikeGrammar",
        one_of(vec![
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("LIKE").to_matchable(),
                    Ref::keyword("ILIKE").to_matchable(),
                ])
                .to_matchable(),
                one_of(vec![
                    Ref::keyword("ALL").to_matchable(),
                    Ref::keyword("ANY").to_matchable(),
                    Ref::keyword("SOME").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("RLIKE").to_matchable(),
            Ref::keyword("REGEXP").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "NotOperatorGrammar",
        one_of(vec![
            StringParser::new("NOT", SyntaxKind::Keyword).to_matchable(),
            StringParser::new("!", SyntaxKind::NotOperator).to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "SingleIdentifierGrammar",
        one_of(vec![
            Ref::new("NakedIdentifierSegment").to_matchable(),
            Ref::new("QuotedIdentifierSegment").to_matchable(),
            Ref::new("SingleQuotedIdentifierSegment").to_matchable(),
            Ref::new("BackQuotedIdentifierSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "WhereClauseTerminatorGrammar",
        one_of(vec![
            Ref::keyword("LIMIT").to_matchable(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("CLUSTER").to_matchable(),
                    Ref::keyword("DISTRIBUTE").to_matchable(),
                    Ref::keyword("GROUP").to_matchable(),
                    Ref::keyword("ORDER").to_matchable(),
                    Ref::keyword("SORT").to_matchable(),
                ])
                .to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("DISTRIBUTE").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("QUALIFY").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::keyword("OVERLAPS").to_matchable(),
            Ref::keyword("APPLY").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "GroupByClauseTerminatorGrammar",
        one_of(vec![
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("ORDER").to_matchable(),
                    Ref::keyword("DISTRIBUTE").to_matchable(),
                    Ref::keyword("CLUSTER").to_matchable(),
                    Ref::keyword("SORT").to_matchable(),
                ])
                .to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "HavingClauseTerminatorGrammar",
        one_of(vec![
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("ORDER").to_matchable(),
                    Ref::keyword("CLUSTER").to_matchable(),
                    Ref::keyword("DISTRIBUTE").to_matchable(),
                    Ref::keyword("SORT").to_matchable(),
                ])
                .to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Ref::keyword("QUALIFY").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "ArithmeticBinaryOperatorGrammar",
        one_of(vec![
            Ref::new("PlusSegment").to_matchable(),
            Ref::new("MinusSegment").to_matchable(),
            Ref::new("DivideSegment").to_matchable(),
            Ref::new("MultiplySegment").to_matchable(),
            Ref::new("ModuloSegment").to_matchable(),
            Ref::new("BitwiseAndSegment").to_matchable(),
            Ref::new("BitwiseOrSegment").to_matchable(),
            Ref::new("BitwiseXorSegment").to_matchable(),
            Ref::new("BitwiseLShiftSegment").to_matchable(),
            Ref::new("BitwiseRShiftSegment").to_matchable(),
            Ref::new("DivBinaryOperatorSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "BinaryOperatorGrammar",
        one_of(vec![
            Ref::new("ArithmeticBinaryOperatorGrammar").to_matchable(),
            Ref::new("StringBinaryOperatorGrammar").to_matchable(),
            Ref::new("BooleanBinaryOperatorGrammar").to_matchable(),
            Ref::new("ComparisonOperatorGrammar").to_matchable(),
            Ref::new("RightArrowOperator").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "AccessorGrammar",
        AnyNumberOf::new(vec![
            Ref::new("ArrayAccessorSegment").to_matchable(),
            Ref::new("SemiStructuredAccessorSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "ObjectReferenceTerminatorGrammar",
        one_of(vec![
            Ref::keyword("ON").to_matchable(),
            Ref::keyword("AS").to_matchable(),
            Ref::keyword("USING").to_matchable(),
            Ref::new("CommaSegment").to_matchable(),
            Ref::new("CastOperatorSegment").to_matchable(),
            Ref::new("StartSquareBracketSegment").to_matchable(),
            Ref::new("StartBracketSegment").to_matchable(),
            Ref::new("BinaryOperatorGrammar").to_matchable(),
            Ref::new("DelimiterGrammar").to_matchable(),
            Ref::new("JoinLikeClauseGrammar").to_matchable(),
            Ref::new("BracketedSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "FunctionContentsExpressionGrammar",
        one_of(vec![
            Ref::new("ExpressionSegment").to_matchable(),
            Ref::new("StarSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.replace_grammar(
        "NonWithNonSelectableGrammar",
        ansi_dialect.grammar("NonWithNonSelectableGrammar").copy(
            Some(vec![
                Ref::new("InsertOverwriteDirectorySegment").to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    sparksql_dialect.replace_grammar(
        "ColumnGeneratedGrammar",
        Sequence::new(vec![
            Ref::keyword("GENERATED").to_matchable(),
            Ref::keyword("ALWAYS").to_matchable(),
            Ref::keyword("AS").to_matchable(),
            Bracketed::new(vec![
                one_of(vec![
                    Ref::new("FunctionSegment").to_matchable(),
                    Ref::new("BareFunctionSegment").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable(),
        ])
        .to_matchable(),
    );

    sparksql_dialect.add([
        (
            "BackQuotedIdentifierSegment".into(),
            TypedParser::new(SyntaxKind::BackQuote, SyntaxKind::QuotedIdentifier)
                .to_matchable()
                .into(),
        ),
        (
            "NakedSemiStructuredElementSegment".into(),
            RegexParser::new(r#"[A-Z0-9_]*"#, SyntaxKind::SemiStructuredElement)
                .to_matchable()
                .into(),
        ),
        (
            "QuotedSemiStructuredElementSegment".into(),
            TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::SemiStructuredElement)
                .to_matchable()
                .into(),
        ),
        (
            "RightArrowOperator".into(),
            StringParser::new("->", SyntaxKind::BinaryOperator)
                .to_matchable()
                .into(),
        ),
        (
            "BINARYFILE".into(),
            StringParser::new("BINARYFILE", SyntaxKind::FileFormat)
                .to_matchable()
                .into(),
        ),
        (
            "JSONFILE".into(),
            StringParser::new("JSONFILE", SyntaxKind::FileFormat)
                .to_matchable()
                .into(),
        ),
        (
            "RCFILE".into(),
            StringParser::new("RCFILE", SyntaxKind::FileFormat)
                .to_matchable()
                .into(),
        ),
        (
            "SEQUENCEFILE".into(),
            StringParser::new("SEQUENCEFILE", SyntaxKind::FileFormat)
                .to_matchable()
                .into(),
        ),
        (
            "TEXTFILE".into(),
            StringParser::new("TEXTFILE", SyntaxKind::FileFormat)
                .to_matchable()
                .into(),
        ),
        (
            "StartAngleBracketSegment".into(),
            StringParser::new("<", SyntaxKind::StartAngleBracket)
                .to_matchable()
                .into(),
        ),
        (
            "EndAngleBracketSegment".into(),
            StringParser::new(">", SyntaxKind::EndAngleBracket)
                .to_matchable()
                .into(),
        ),
        (
            "EqualsSegment_a".into(),
            StringParser::new("==", SyntaxKind::ComparisonOperator)
                .to_matchable()
                .into(),
        ),
        (
            "EqualsSegment_b".into(),
            StringParser::new("<=>", SyntaxKind::ComparisonOperator)
                .to_matchable()
                .into(),
        ),
        (
            "FILE".into(),
            MultiStringParser::new(
                vec!["FILE", "FILES"]
                    .into_iter()
                    .map(String::from)
                    .collect::<Vec<_>>(),
                SyntaxKind::FileKeyword,
            )
            .to_matchable()
            .into(),
        ),
        (
            "JAR".into(),
            MultiStringParser::new(
                vec!["JAR", "JARS"]
                    .into_iter()
                    .map(String::from)
                    .collect::<Vec<_>>(),
                SyntaxKind::FileKeyword,
            )
            .to_matchable()
            .into(),
        ),
        (
            "NOSCAN".into(),
            StringParser::new("NOSCAN", SyntaxKind::Keyword)
                .to_matchable()
                .into(),
        ),
        (
            "WHL".into(),
            StringParser::new("WHL", SyntaxKind::FileKeyword)
                .to_matchable()
                .into(),
        ),
        (
            "CommentGrammar".into(),
            hive_dialect.grammar("CommentGrammar").into(),
        ),
        (
            "LocationGrammar".into(),
            hive_dialect.grammar("LocationGrammar").into(),
        ),
        (
            "SerdePropertiesGrammar".into(),
            hive_dialect.grammar("SerdePropertiesGrammar").into(),
        ),
        (
            "StoredAsGrammar".into(),
            hive_dialect.grammar("StoredAsGrammar").into(),
        ),
        (
            "StoredByGrammar".into(),
            hive_dialect.grammar("StoredByGrammar").into(),
        ),
        (
            "StorageFormatGrammar".into(),
            hive_dialect.grammar("StorageFormatGrammar").into(),
        ),
        (
            "TerminatedByGrammar".into(),
            hive_dialect.grammar("TerminatedByGrammar").into(),
        ),
        (
            "PropertyGrammar".into(),
            Sequence::new(vec![
                Ref::new("PropertyNameSegment").to_matchable(),
                Ref::new("EqualsSegment").optional().to_matchable(),
                one_of(vec![
                    Ref::new("LiteralGrammar").to_matchable(),
                    Delimited::new(vec![
                        Ref::new("PropertiesNakedIdentifierSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.delimiter(Ref::new("DotSegment"));
                    })
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "PropertyNameListGrammar".into(),
            Delimited::new(vec![Ref::new("PropertyNameSegment").to_matchable()])
                .to_matchable()
                .into(),
        ),
        (
            "BracketedPropertyNameListGrammar".into(),
            Bracketed::new(vec![Ref::new("PropertyNameListGrammar").to_matchable()])
                .to_matchable()
                .into(),
        ),
        (
            "PropertyListGrammar".into(),
            Delimited::new(vec![Ref::new("PropertyGrammar").to_matchable()])
                .to_matchable()
                .into(),
        ),
        (
            "BracketedPropertyListGrammar".into(),
            Bracketed::new(vec![Ref::new("PropertyListGrammar").to_matchable()])
                .to_matchable()
                .into(),
        ),
        (
            "OptionsGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("OPTIONS").to_matchable(),
                Ref::new("BracketedPropertyListGrammar").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "BucketSpecGrammar".into(),
            Sequence::new(vec![
                Ref::new("ClusteredBySpecGrammar").to_matchable(),
                Ref::new("SortedBySpecGrammar").optional().to_matchable(),
                Ref::keyword("INTO").to_matchable(),
                Ref::new("NumericLiteralSegment").to_matchable(),
                Ref::keyword("BUCKETS").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ClusteredBySpecGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("CLUSTERED").to_matchable(),
                Ref::keyword("BY").to_matchable(),
                Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "DatabasePropertiesGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("DBPROPERTIES").to_matchable(),
                Ref::new("BracketedPropertyListGrammar").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "DataSourcesV2FileTypeGrammar".into(),
            one_of(vec![
                Ref::keyword("AVRO").to_matchable(),
                Ref::keyword("CSV").to_matchable(),
                Ref::keyword("JSON").to_matchable(),
                Ref::keyword("PARQUET").to_matchable(),
                Ref::keyword("ORC").to_matchable(),
                Ref::keyword("DELTA").to_matchable(),
                Ref::keyword("CSV").to_matchable(),
                Ref::keyword("ICEBERG").to_matchable(),
                Ref::keyword("TEXT").to_matchable(),
                Ref::keyword("BINARYFILE").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "DescribeObjectGrammar".into(),
            one_of(vec![
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("DATABASE").to_matchable(),
                        Ref::keyword("SCHEMA").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("EXTENDED").optional().to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("FUNCTION").to_matchable(),
                    Ref::keyword("EXTENDED").optional().to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("TABLE").optional().to_matchable(),
                    Ref::keyword("EXTENDED").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                        AnyNumberOf::new(vec![
                            Sequence::new(vec![
                                Ref::new("DotSegment").to_matchable(),
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                            ])
                            .config(|this| {
                                this.disallow_gaps();
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.max_times(2);
                        })
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                        this.disallow_gaps();
                    })
                    .to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("QUERY").optional().to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("TABLE").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("FROM").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                            Ref::keyword("SELECT").to_matchable(),
                            Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                                .to_matchable(),
                            Ref::new("WhereClauseSegment").optional().to_matchable(),
                            Ref::new("GroupByClauseSegment").optional().to_matchable(),
                            Ref::new("OrderByClauseSegment").optional().to_matchable(),
                            Ref::new("LimitClauseSegment").optional().to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("StatementSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .config(|this| {
                this.exclude = Some(
                    one_of(vec![
                        Ref::keyword("HISTORY").to_matchable(),
                        Ref::keyword("DETAIL").to_matchable(),
                    ])
                    .to_matchable(),
                );
            })
            .to_matchable()
            .into(),
        ),
        (
            "FileFormatGrammar".into(),
            one_of(vec![
                Ref::new("DataSourcesV2FileTypeGrammar").to_matchable(),
                Ref::keyword("SEQUENCEFILE").to_matchable(),
                Ref::keyword("TEXTFILE").to_matchable(),
                Ref::keyword("RCFILE").to_matchable(),
                Ref::keyword("JSONFILE").to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("INPUTFORMAT").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Ref::keyword("OUTPUTFORMAT").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "TimestampAsOfGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("TIMESTAMP").to_matchable(),
                Ref::keyword("AS").to_matchable(),
                Ref::keyword("OF").to_matchable(),
                one_of(vec![
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Ref::new("BareFunctionSegment").to_matchable(),
                    Ref::new("FunctionSegment").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "VersionAsOfGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("VERSION").to_matchable(),
                Ref::keyword("AS").to_matchable(),
                Ref::keyword("OF").to_matchable(),
                Ref::new("NumericLiteralSegment").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "InsertSourceGrammar".into(),
            one_of(vec![
                AnyNumberOf::new(vec![Ref::new("ValuesClauseSegment").to_matchable()])
                    .config(|this| {
                        this.min_times(1);
                    })
                    .to_matchable(),
                Ref::new("SelectableGrammar").to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("TABLE").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("FROM").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::keyword("SELECT").to_matchable(),
                    Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                        .to_matchable(),
                    Ref::new("WhereClauseSegment").optional().to_matchable(),
                    Ref::new("GroupByClauseSegment").optional().to_matchable(),
                    Ref::new("OrderByClauseSegment").optional().to_matchable(),
                    Ref::new("LimitClauseSegment").optional().to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "StartHintSegment".into(),
            StringParser::new("/*+", SyntaxKind::StartHint)
                .to_matchable()
                .into(),
        ),
        (
            "EndHintSegment".into(),
            StringParser::new("*/", SyntaxKind::EndHint)
                .to_matchable()
                .into(),
        ),
        (
            "PartitionSpecGrammar".into(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("PARTITION").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("PARTITIONED").to_matchable(),
                        Ref::keyword("BY").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
                Bracketed::new(vec![
                    Delimited::new(vec![
                        one_of(vec![
                            Ref::new("ColumnDefinitionSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("EqualsSegment").optional().to_matchable(),
                                Ref::new("LiteralGrammar").optional().to_matchable(),
                                Ref::new("CommentGrammar").optional().to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("IcebergTransformationSegment")
                                .optional()
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "PartitionFieldGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("PARTITION").to_matchable(),
                Ref::keyword("FIELD").to_matchable(),
                Delimited::new(vec![
                    one_of(vec![
                        Ref::new("ColumnDefinitionSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("EqualsSegment").optional().to_matchable(),
                            Ref::new("LiteralGrammar").optional().to_matchable(),
                            Ref::new("CommentGrammar").optional().to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("IcebergTransformationSegment")
                            .optional()
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("WITH").optional().to_matchable(),
                    Delimited::new(vec![
                        one_of(vec![
                            Ref::new("ColumnDefinitionSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("EqualsSegment").optional().to_matchable(),
                                Ref::new("LiteralGrammar").optional().to_matchable(),
                                Ref::new("CommentGrammar").optional().to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("IcebergTransformationSegment")
                                .optional()
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("AS").to_matchable(),
                    Ref::new("NakedIdentifierSegment").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "PropertiesNakedIdentifierSegment".into(),
            RegexParser::new(
                r#"[A-Z0-9]*[A-Z][A-Z0-9]*"#,
                SyntaxKind::PropertiesNakedIdentifier,
            )
            .to_matchable()
            .into(),
        ),
        (
            "ResourceFileGrammar".into(),
            one_of(vec![
                Ref::keyword("JAR").to_matchable(),
                Ref::keyword("WHL").to_matchable(),
                Ref::keyword("FILE").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ResourceLocationGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("USING").to_matchable(),
                Ref::new("ResourceFileGrammar").to_matchable(),
                Ref::new("QuotedLiteralSegment").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "SortedBySpecGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("SORTED").to_matchable(),
                Ref::keyword("BY").to_matchable(),
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            one_of(vec![
                                Ref::keyword("ASC").to_matchable(),
                                Ref::keyword("DESC").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .config(|this| {
                this.optional();
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnsetTablePropertiesGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("UNSET").to_matchable(),
                Ref::keyword("TBLPROPERTIES").to_matchable(),
                Ref::new("IfExistsGrammar").optional().to_matchable(),
                Ref::new("BracketedPropertyNameListGrammar").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "TablePropertiesGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("TBLPROPERTIES").to_matchable(),
                Ref::new("BracketedPropertyListGrammar").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "CreateViewClausesGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("WITH").to_matchable(),
                Ref::keyword("SCHEMA").to_matchable(),
                one_of(vec![
                    Ref::keyword("BINDING").to_matchable(),
                    Ref::keyword("COMPENSATION").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("TYPE").optional().to_matchable(),
                        Ref::keyword("EVOLUTION").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "RawQuotedLiteralSegment".into(),
            one_of(vec![
                TypedParser::new(SyntaxKind::RawSingleQuote, SyntaxKind::RawQuotedLiteral)
                    .to_matchable(),
                TypedParser::new(SyntaxKind::RawDoubleQuote, SyntaxKind::RawQuotedLiteral)
                    .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "BytesQuotedLiteralSegment".into(),
            one_of(vec![
                TypedParser::new(SyntaxKind::BytesSingleQuote, SyntaxKind::BytesQuotedLiteral)
                    .to_matchable(),
                TypedParser::new(SyntaxKind::BytesDoubleQuote, SyntaxKind::BytesQuotedLiteral)
                    .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "JoinTypeKeywords".into(),
            one_of(vec![
                Ref::keyword("CROSS").to_matchable(),
                Ref::keyword("INNER").to_matchable(),
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("FULL").to_matchable(),
                        Ref::keyword("LEFT").to_matchable(),
                        Ref::keyword("RIGHT").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("OUTER").optional().to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("LEFT").optional().to_matchable(),
                    Ref::keyword("SEMI").to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("LEFT").optional().to_matchable(),
                    Ref::keyword("ANTI").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "AtSignLiteralSegment".into(),
            TypedParser::new(SyntaxKind::AtSignLiteral, SyntaxKind::AtSignLiteral)
                .to_matchable()
                .into(),
        ),
        (
            "SignedQuotedLiteralSegment".into(),
            one_of(vec![
                TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::SignedQuotedLiteral)
                    .to_matchable(),
                TypedParser::new(SyntaxKind::DoubleQuote, SyntaxKind::SignedQuotedLiteral)
                    .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "OrRefreshGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("OR").to_matchable(),
                Ref::keyword("REFRESH").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "WidgetNameIdentifierSegment".into(),
            RegexParser::new(r#"[A-Z][A-Z0-9_]*"#, SyntaxKind::WidgetNameIdentifier)
                .to_matchable()
                .into(),
        ),
        (
            "WidgetDefaultGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("DEFAULT").to_matchable(),
                Ref::new("QuotedLiteralSegment").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "TableDefinitionSegment".into(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::new("OrReplaceGrammar").to_matchable(),
                    Ref::new("OrRefreshGrammar").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Ref::new("TemporaryGrammar").optional().to_matchable(),
                Ref::keyword("EXTERNAL").optional().to_matchable(),
                Ref::keyword("STREAMING").optional().to_matchable(),
                Ref::keyword("LIVE").optional().to_matchable(),
                Ref::keyword("TABLE").to_matchable(),
                Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                one_of(vec![
                    Ref::new("FileReferenceSegment").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable(),
                one_of(vec![
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::new("ColumnFieldDefinitionSegment").to_matchable(),
                                    Ref::new("TableConstraintSegment").optional().to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("CommentGrammar").optional().to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::new("ConstraintStatementSegment")
                                .optional()
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("LIKE").to_matchable(),
                        one_of(vec![
                            Ref::new("FileReferenceSegment").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Ref::new("UsingClauseSegment").optional().to_matchable(),
                AnyNumberOf::new(vec![
                    Ref::new("RowFormatClauseSegment").to_matchable(),
                    Ref::new("StoredAsGrammar").to_matchable(),
                    Ref::new("CommentGrammar").to_matchable(),
                    Ref::new("OptionsGrammar").to_matchable(),
                    Ref::new("PartitionSpecGrammar").to_matchable(),
                    Ref::new("BucketSpecGrammar").to_matchable(),
                    Ref::new("LocationGrammar").to_matchable(),
                    Ref::new("CommentGrammar").to_matchable(),
                    Ref::new("TablePropertiesGrammar").to_matchable(),
                    Ref::new("TableClusterByClauseSegment").to_matchable(),
                ])
                .config(|this| {
                    this.max_times_per_element = Some(1);
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("AS").optional().to_matchable(),
                    optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "FirstOrAfterGrammar".into(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("FIRST").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AFTER").to_matchable(),
                        Ref::new("ColumnReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ShowDatabasesSchemasGrammar".into(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("DATABASES").to_matchable(),
                    Ref::keyword("SCHEMAS").to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("LIKE").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ShowFunctionsGrammar".into(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("USER").to_matchable(),
                    Ref::keyword("SYSTEM").to_matchable(),
                    Ref::keyword("ALL").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Ref::keyword("FUNCTIONS").to_matchable(),
                one_of(vec![
                    Sequence::new(vec![
                        Ref::new("DatabaseReferenceSegment").to_matchable(),
                        Ref::new("DotSegment").to_matchable(),
                        Ref::new("FunctionNameSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                        this.disallow_gaps();
                    })
                    .to_matchable(),
                    Ref::new("FunctionNameSegment").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("LIKE").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ShowTablesGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("TABLES").to_matchable(),
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("FROM").to_matchable(),
                        Ref::keyword("IN").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("LIKE").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ShowViewsGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("VIEWS").to_matchable(),
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("FROM").to_matchable(),
                        Ref::keyword("IN").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("LIKE").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
        (
            "ShowObjectGrammar".into(),
            one_of(vec![
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("TableExpressionSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        Ref::keyword("SERDE").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("COLUMNS").to_matchable(),
                    Ref::keyword("IN").to_matchable(),
                    Ref::new("TableExpressionSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("IN").to_matchable(),
                        Ref::new("DatabaseReferenceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("PARTITIONS").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::keyword("EXTENDED").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("FROM").to_matchable(),
                            Ref::keyword("IN").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DatabaseReferenceSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::keyword("LIKE").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                ])
                .to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("TBLPROPERTIES").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("BracketedPropertyNameListGrammar")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable(),
                Ref::new("ShowDatabasesSchemasGrammar").to_matchable(),
                Ref::new("ShowFunctionsGrammar").to_matchable(),
                Ref::new("ShowTablesGrammar").to_matchable(),
                Ref::new("ShowViewsGrammar").to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
    ]);

    sparksql_dialect.insert_lexer_matchers(
        vec![Matcher::string(
            "start_hint",
            r#"/*+"#,
            SyntaxKind::StartHint,
        )],
        "block_comment",
    );

    sparksql_dialect.insert_lexer_matchers(
        vec![Matcher::string("end_hint", r#"*/"#, SyntaxKind::EndHint)],
        "single_quote",
    );

    sparksql_dialect.insert_lexer_matchers(
        vec![Matcher::string(
            "right_arrow",
            r#"->"#,
            SyntaxKind::RightArrow,
        )],
        "like_operator",
    );

    sparksql_dialect.add([
        (
            "SQLConfPropertiesSegment".into(),
            NodeMatcher::new(SyntaxKind::SqlConfOption, |_dialect| {
                Sequence::new(vec![
                    StringParser::new("-", SyntaxKind::Dash).to_matchable(),
                    StringParser::new("v", SyntaxKind::SqlConfOption).to_matchable(),
                ])
                .config(|this| {
                    this.disallow_gaps();
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DivBinaryOperatorSegment".into(),
            NodeMatcher::new(SyntaxKind::BinaryOperator, |_dialect| {
                Ref::keyword("DIV").to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "QualifyClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::QualifyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("QUALIFY").to_matchable(),
                    MetaSegment::implicit_indent().to_matchable(),
                    optionally_bracketed(vec![Ref::new("ExpressionSegment").to_matchable()])
                        .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RowFormatClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::RowFormatClause, |_dialect| {
                let dialect = super::hive::raw_dialect();
                dialect
                    .grammar("RowFormatClauseSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SkewedByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::SkewedByClause, |_dialect| {
                let dialect = super::hive::raw_dialect();
                dialect
                    .grammar("SkewedByClauseSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PrimitiveTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::PrimitiveType, |_dialect| {
                one_of(vec![
                    Ref::keyword("BOOLEAN").to_matchable(),
                    Ref::keyword("TINYINT").to_matchable(),
                    Ref::keyword("LONG").to_matchable(),
                    Ref::keyword("SMALLINT").to_matchable(),
                    Ref::keyword("INT").to_matchable(),
                    Ref::keyword("INTEGER").to_matchable(),
                    Ref::keyword("BIGINT").to_matchable(),
                    Ref::keyword("FLOAT").to_matchable(),
                    Ref::keyword("REAL").to_matchable(),
                    Ref::keyword("DOUBLE").to_matchable(),
                    Ref::keyword("DATE").to_matchable(),
                    Ref::keyword("TIMESTAMP").to_matchable(),
                    Ref::keyword("TIMESTAMP_LTZ").to_matchable(),
                    Ref::keyword("TIMESTAMP_NTZ").to_matchable(),
                    Ref::keyword("STRING").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("CHAR").to_matchable(),
                            Ref::keyword("CHARACTER").to_matchable(),
                            Ref::keyword("VARCHAR").to_matchable(),
                            Ref::keyword("DECIMAL").to_matchable(),
                            Ref::keyword("DEC").to_matchable(),
                            Ref::keyword("NUMERIC").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("BracketedArguments").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("BINARY").to_matchable(),
                    Ref::keyword("INTERVAL").to_matchable(),
                    Ref::keyword("VARIANT").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::ArrayType, |_dialect| {
                let dialect = super::hive::raw_dialect();
                dialect
                    .grammar("ArrayTypeSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StructTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::StructType, |_dialect| {
                let dialect = super::hive::raw_dialect();
                dialect
                    .grammar("StructTypeSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StructTypeSchemaSegment".into(),
            NodeMatcher::new(SyntaxKind::StructTypeSchema, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                            Ref::new("ColonSegment").optional().to_matchable(),
                            Ref::new("DatatypeSegment").to_matchable(),
                            Ref::new("CommentGrammar").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.bracket_type("angle");
                    this.bracket_pairs_set = "angle_bracket_pairs";
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SemiStructuredAccessorSegment".into(),
            NodeMatcher::new(SyntaxKind::SemiStructuredExpression, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::new("DotSegment").to_matchable(),
                        Ref::new("ColonSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Ref::new("NakedSemiStructuredElementSegment").to_matchable(),
                        Bracketed::new(vec![
                            Ref::new("QuotedSemiStructuredElementSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.bracket_type("square");
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("ArrayAccessorSegment").optional().to_matchable(),
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::new("DotSegment").to_matchable(),
                                Ref::new("ColonSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            one_of(vec![
                                Ref::new("NakedSemiStructuredElementSegment").to_matchable(),
                                Bracketed::new(vec![
                                    Ref::new("QuotedSemiStructuredElementSegment").to_matchable(),
                                ])
                                .config(|this| {
                                    this.bracket_type("square");
                                })
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ArrayAccessorSegment").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DatatypeSegment".into(),
            NodeMatcher::new(SyntaxKind::DataType, |_dialect| {
                one_of(vec![
                    Ref::new("PrimitiveTypeSegment").to_matchable(),
                    Ref::new("ArrayTypeSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("MAP").to_matchable(),
                        Bracketed::new(vec![
                            Sequence::new(vec![
                                Ref::new("DatatypeSegment").to_matchable(),
                                Ref::new("CommaSegment").to_matchable(),
                                Ref::new("DatatypeSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.bracket_type("angle");
                            this.bracket_pairs_set = "angle_bracket_pairs";
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("StructTypeSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterDatabaseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterDatabaseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    one_of(vec![
                        Ref::keyword("DATABASE").to_matchable(),
                        Ref::keyword("SCHEMA").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                    Ref::keyword("SET").to_matchable(),
                    one_of(vec![
                        Ref::new("DatabasePropertiesGrammar").to_matchable(),
                        Ref::new("LocationGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("PartitionSpecGrammar").to_matchable(),
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("PartitionSpecGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ADD").to_matchable(),
                            one_of(vec![
                                Ref::keyword("COLUMNS").to_matchable(),
                                Ref::keyword("COLUMN").to_matchable(),
                            ])
                            .to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            optionally_bracketed(vec![
                                Delimited::new(vec![
                                    Sequence::new(vec![
                                        Ref::new("ColumnFieldDefinitionSegment").to_matchable(),
                                        Ref::new("FirstOrAfterGrammar").optional().to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::keyword("ALTER").to_matchable(),
                                Ref::keyword("CHANGE").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("COLUMN").optional().to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            AnyNumberOf::new(vec![
                                Ref::new("ColumnReferenceSegment")
                                    .exclude(one_of(vec![
                                        Ref::keyword("COMMENT").to_matchable(),
                                        Ref::keyword("TYPE").to_matchable(),
                                        Ref::new("DatatypeSegment").to_matchable(),
                                        Ref::keyword("FIRST").to_matchable(),
                                        Ref::keyword("AFTER").to_matchable(),
                                        Ref::keyword("SET").to_matchable(),
                                        Ref::keyword("DROP").to_matchable(),
                                    ]))
                                    .to_matchable(),
                            ])
                            .config(|this| {
                                this.max_times(2);
                            })
                            .to_matchable(),
                            Ref::keyword("TYPE").optional().to_matchable(),
                            Ref::new("DatatypeSegment").optional().to_matchable(),
                            Ref::new("CommentGrammar").optional().to_matchable(),
                            Ref::new("FirstOrAfterGrammar").optional().to_matchable(),
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::keyword("SET").to_matchable(),
                                    Ref::keyword("DROP").to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::keyword("NOT").to_matchable(),
                                Ref::keyword("NULL").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REPLACE").to_matchable(),
                            Ref::keyword("COLUMNS").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Sequence::new(vec![
                                        Ref::new("ColumnDefinitionSegment").to_matchable(),
                                        Ref::new("CommentGrammar").optional().to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("COLUMN").to_matchable(),
                                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("COLUMNS").to_matchable(),
                                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                                    Bracketed::new(vec![
                                        Delimited::new(vec![
                                            AnyNumberOf::new(vec![
                                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ADD").to_matchable(),
                            Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                            AnyNumberOf::new(vec![
                                Ref::new("PartitionSpecGrammar").to_matchable(),
                                Ref::new("PartitionFieldGrammar").to_matchable(),
                            ])
                            .config(|this| {
                                this.min_times(1);
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            Ref::new("IfExistsGrammar").optional().to_matchable(),
                            one_of(vec![
                                Ref::new("PartitionSpecGrammar").to_matchable(),
                                Ref::new("PartitionFieldGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![Ref::keyword("PURGE").to_matchable()])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REPLACE").to_matchable(),
                            Ref::new("PartitionFieldGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("RECOVER").to_matchable(),
                            Ref::keyword("PARTITIONS").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("TablePropertiesGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("UnsetTablePropertiesGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                            Ref::keyword("SET").to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("SERDEPROPERTIES").to_matchable(),
                                    Ref::new("BracketedPropertyListGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("SERDE").to_matchable(),
                                    Ref::new("QuotedLiteralSegment").to_matchable(),
                                    Ref::new("SerdePropertiesGrammar").optional().to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                            Ref::keyword("SET").to_matchable(),
                            Ref::keyword("FILEFORMAT").to_matchable(),
                            Ref::new("DataSourceFormatSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("LocationGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            MetaSegment::indent().to_matchable(),
                            one_of(vec![
                                Ref::keyword("ADD").to_matchable(),
                                Ref::keyword("DROP").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("CONSTRAINT").to_matchable(),
                            Ref::new("ColumnReferenceSegment")
                                .exclude(Ref::keyword("CHECK"))
                                .to_matchable(),
                            Ref::keyword("CHECK").optional().to_matchable(),
                            Bracketed::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("WRITE").to_matchable(),
                            AnyNumberOf::new(vec![
                                Sequence::new(vec![
                                    Ref::keyword("DISTRIBUTED").to_matchable(),
                                    Ref::keyword("BY").to_matchable(),
                                    Ref::keyword("PARTITION").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("LOCALLY").optional().to_matchable(),
                                    Ref::keyword("ORDERED").to_matchable(),
                                    Ref::keyword("BY").to_matchable(),
                                    MetaSegment::indent().to_matchable(),
                                    Delimited::new(vec![
                                        Sequence::new(vec![
                                            Ref::new("ColumnReferenceSegment").to_matchable(),
                                            one_of(vec![
                                                Ref::keyword("ASC").to_matchable(),
                                                Ref::keyword("DESC").to_matchable(),
                                            ])
                                            .config(|this| {
                                                this.optional();
                                            })
                                            .to_matchable(),
                                            Sequence::new(vec![
                                                Ref::keyword("NULLS").to_matchable(),
                                                one_of(vec![
                                                    Ref::keyword("FIRST").to_matchable(),
                                                    Ref::keyword("LAST").to_matchable(),
                                                ])
                                                .to_matchable(),
                                            ])
                                            .config(|this| {
                                                this.optional();
                                            })
                                            .to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .config(|this| {
                                        this.optional();
                                    })
                                    .to_matchable(),
                                    MetaSegment::dedent().to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.min_times(1);
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::keyword("IDENTIFIER").to_matchable(),
                            Ref::keyword("FIELDS").to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            Ref::keyword("IDENTIFIER").to_matchable(),
                            Ref::keyword("FIELDS").to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnFieldDefinitionSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnDefinition, |_dialect| {
                Sequence::new(vec![
                    Ref::new("ColumnReferenceSegment").to_matchable(),
                    Ref::new("DatatypeSegment").to_matchable(),
                    Bracketed::new(vec![Anything::new().to_matchable()])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("ColumnConstraintSegment")
                            .optional()
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableClusterByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::TableClusterByClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CLUSTER").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                        Ref::keyword("NONE").to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("TablePropertiesGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("UnsetTablePropertiesGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("AS").to_matchable(),
                            optionally_bracketed(vec![
                                Ref::new("SelectStatementSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateDatabaseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateDatabaseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    one_of(vec![
                        Ref::keyword("DATABASE").to_matchable(),
                        Ref::keyword("SCHEMA").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                    Ref::new("CommentGrammar").optional().to_matchable(),
                    Ref::new("LocationGrammar").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Ref::keyword("DBPROPERTIES").to_matchable(),
                        Ref::new("BracketedPropertyListGrammar").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FunctionParameterListGrammarWithComments".into(),
            NodeMatcher::new(SyntaxKind::FunctionParameterListWithComments, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            Ref::new("FunctionParameterGrammar").to_matchable(),
                            AnyNumberOf::new(vec![
                                Sequence::new(vec![
                                    Ref::keyword("DEFAULT").to_matchable(),
                                    Ref::new("LiteralGrammar").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                                Ref::new("CommentClauseSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::new("TemporaryGrammar").optional().to_matchable(),
                    Ref::keyword("FUNCTION").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("FunctionNameIdentifierSegment").to_matchable(),
                    Ref::keyword("AS").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Ref::new("ResourceLocationGrammar")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("TableDefinitionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateViewStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateViewStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    one_of(vec![
                        Ref::new("OrReplaceGrammar").to_matchable(),
                        Ref::new("OrRefreshGrammar").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("TemporaryGrammar").optional().to_matchable(),
                    Ref::keyword("STREAMING").optional().to_matchable(),
                    Ref::keyword("LIVE").optional().to_matchable(),
                    Ref::keyword("MATERIALIZED").optional().to_matchable(),
                    Ref::keyword("VIEW").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                    Ref::new("DatatypeSegment").optional().to_matchable(),
                                    Ref::new("CommentGrammar").optional().to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("ConstraintStatementSegment")
                                    .optional()
                                    .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("USING").to_matchable(),
                        Ref::new("DataSourceFormatSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("OptionsGrammar").optional().to_matchable(),
                    one_of(vec![
                        Ref::new("PartitionSpecGrammar").to_matchable(),
                        Ref::new("TableClusterByClauseSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("CommentGrammar").optional().to_matchable(),
                    Ref::new("TablePropertiesGrammar").optional().to_matchable(),
                    Ref::new("CreateViewClausesGrammar")
                        .optional()
                        .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("WithNoSchemaBindingClauseSegment")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateWidgetStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateWidgetStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::keyword("WIDGET").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("DROPDOWN").to_matchable(),
                            Ref::new("WidgetNameIdentifierSegment").to_matchable(),
                            Ref::new("WidgetDefaultGrammar").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("CHOICES").to_matchable(),
                                Ref::new("SelectStatementSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("TEXT").to_matchable(),
                            Ref::new("WidgetNameIdentifierSegment").to_matchable(),
                            Ref::new("WidgetDefaultGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ReplaceTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ReplaceTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("REPLACE").to_matchable(),
                    Ref::new("TableDefinitionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RemoveWidgetStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::RemoveWidgetStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("REMOVE").to_matchable(),
                    Ref::keyword("WIDGET").to_matchable(),
                    Ref::new("WidgetNameIdentifierSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropDatabaseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropDatabaseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    one_of(vec![
                        Ref::keyword("DATABASE").to_matchable(),
                        Ref::keyword("SCHEMA").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                    Ref::new("DropBehaviorGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DropFunctionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DropFunctionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DROP").to_matchable(),
                    Ref::new("TemporaryGrammar").optional().to_matchable(),
                    Ref::keyword("FUNCTION").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("FunctionNameSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MsckRepairTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::MsckRepairTableStatement, |_dialect| {
                let dialect = super::hive::raw_dialect();
                dialect
                    .grammar("MsckRepairTableStatementSegment")
                    .match_grammar(&dialect)
                    .unwrap()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TruncateStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::TruncateStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("TRUNCATE").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UseDatabaseStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::UseDatabaseStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("USE").to_matchable(),
                    Ref::new("DatabaseReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "InsertStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::InsertStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INSERT").to_matchable(),
                    one_of(vec![
                        Ref::keyword("INTO").to_matchable(),
                        Ref::keyword("OVERWRITE").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("TABLE").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                            Ref::new("BracketedColumnReferenceListGrammar")
                                .optional()
                                .to_matchable(),
                            Ref::new("InsertSourceGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REPLACE").to_matchable(),
                            Ref::new("WhereClauseSegment").to_matchable(),
                            Ref::new("InsertSourceGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("REPLACE").to_matchable(),
                            Ref::keyword("USING").to_matchable(),
                            Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                            Ref::new("InsertSourceGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "InsertOverwriteDirectorySegment".into(),
            NodeMatcher::new(SyntaxKind::InsertOverwriteDirectoryStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INSERT").to_matchable(),
                    Ref::keyword("OVERWRITE").to_matchable(),
                    Ref::keyword("LOCAL").optional().to_matchable(),
                    Ref::keyword("DIRECTORY").to_matchable(),
                    Ref::new("QuotedLiteralSegment").optional().to_matchable(),
                    Ref::keyword("USING").to_matchable(),
                    Ref::new("DataSourceFormatSegment").to_matchable(),
                    Ref::new("OptionsGrammar").optional().to_matchable(),
                    one_of(vec![
                        AnyNumberOf::new(vec![Ref::new("ValuesClauseSegment").to_matchable()])
                            .config(|this| {
                                this.min_times(1);
                            })
                            .to_matchable(),
                        Ref::new("SelectableGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "InsertOverwriteDirectoryHiveFmtSegment".into(),
            NodeMatcher::new(
                SyntaxKind::InsertOverwriteDirectoryHiveFmtStatement,
                |_dialect| {
                    Sequence::new(vec![
                        Ref::keyword("INSERT").to_matchable(),
                        Ref::keyword("OVERWRITE").to_matchable(),
                        Ref::keyword("LOCAL").optional().to_matchable(),
                        Ref::keyword("DIRECTORY").to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("RowFormatClauseSegment").optional().to_matchable(),
                        Ref::new("StoredAsGrammar").optional().to_matchable(),
                        one_of(vec![
                            AnyNumberOf::new(vec![Ref::new("ValuesClauseSegment").to_matchable()])
                                .config(|this| {
                                    this.min_times(1);
                                })
                                .to_matchable(),
                            Ref::new("SelectableGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable()
                },
            )
            .to_matchable()
            .into(),
        ),
        (
            "LoadDataSegment".into(),
            NodeMatcher::new(SyntaxKind::LoadDataStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("LOAD").to_matchable(),
                    Ref::keyword("DATA").to_matchable(),
                    Ref::keyword("LOCAL").optional().to_matchable(),
                    Ref::keyword("INPATH").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Ref::keyword("OVERWRITE").optional().to_matchable(),
                    Ref::keyword("INTO").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ClusterByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::ClusterByClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CLUSTER").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.terminators = vec![
                            Ref::keyword("LIMIT").to_matchable(),
                            Ref::keyword("HAVING").to_matchable(),
                            Ref::keyword("WINDOW").to_matchable(),
                            Ref::new("FrameClauseUnitGrammar").to_matchable(),
                            Ref::keyword("SEPARATOR").to_matchable(),
                        ];
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DistributeByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::DistributeByClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DISTRIBUTE").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.terminators = vec![
                            Ref::keyword("SORT").to_matchable(),
                            Ref::keyword("LIMIT").to_matchable(),
                            Ref::keyword("HAVING").to_matchable(),
                            Ref::keyword("WINDOW").to_matchable(),
                            Ref::new("FrameClauseUnitGrammar").to_matchable(),
                            Ref::keyword("SEPARATOR").to_matchable(),
                        ];
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "HintFunctionSegment".into(),
            NodeMatcher::new(SyntaxKind::HintFunction, |_dialect| {
                Sequence::new(vec![
                    Ref::new("FunctionNameSegment").to_matchable(),
                    Ref::new("FunctionContentsSegment")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectHintSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectHint, |_dialect| {
                Sequence::new(vec![
                    Sequence::new(vec![
                        Ref::new("StartHintSegment").to_matchable(),
                        Delimited::new(vec![
                            AnyNumberOf::new(vec![Ref::new("HintFunctionSegment").to_matchable()])
                                .config(|this| {
                                    this.min_times(1);
                                })
                                .to_matchable(),
                        ])
                        .config(|this| {
                            this.terminators = vec![Ref::new("EndHintSegment").to_matchable()];
                        })
                        .to_matchable(),
                        Ref::new("EndHintSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LimitClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::LimitClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("LIMIT").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Ref::new("NumericLiteralSegment").to_matchable(),
                        Ref::keyword("ALL").to_matchable(),
                        Ref::new("FunctionSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetOperatorSegment".into(),
            NodeMatcher::new(SyntaxKind::SetOperator, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("EXCEPT").to_matchable(),
                            Ref::keyword("MINUS").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("ALL").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("UNION").to_matchable(),
                            Ref::keyword("INTERSECT").to_matchable(),
                        ])
                        .to_matchable(),
                        one_of(vec![
                            Ref::keyword("DISTINCT").to_matchable(),
                            Ref::keyword("ALL").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.exclude = Some(
                        Sequence::new(vec![
                            Ref::keyword("EXCEPT").to_matchable(),
                            Bracketed::new(vec![Anything::new().to_matchable()]).to_matchable(),
                        ])
                        .to_matchable(),
                    );
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectClauseModifierSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectClauseModifier, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SelectHintSegment").optional().to_matchable(),
                    one_of(vec![
                        Ref::keyword("DISTINCT").to_matchable(),
                        Ref::keyword("ALL").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnorderedSelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("UnorderedSelectStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("QualifyClauseSegment").optional().to_matchable(),
                        Ref::new("ClusterByClauseSegment").optional().to_matchable(),
                        Ref::new("DistributeByClauseSegment")
                            .optional()
                            .to_matchable(),
                        Ref::new("SortByClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    None,
                    Some(vec![
                        Ref::new("OverlapsClauseSegment").optional().to_matchable(),
                    ]),
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("SelectStatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("ClusterByClauseSegment").optional().to_matchable(),
                        Ref::new("DistributeByClauseSegment")
                            .optional()
                            .to_matchable(),
                        Ref::new("SortByClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    Some(Ref::new("LimitClauseSegment").optional().to_matchable()),
                    None,
                    vec![],
                    false,
                )
                .copy(
                    Some(vec![
                        Ref::new("QualifyClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    Some(Ref::new("OrderByClauseSegment").optional().to_matchable()),
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "GroupByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::GroupbyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("GROUP").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Delimited::new(vec![
                            Ref::new("CubeRollupClauseSegment").to_matchable(),
                            Ref::new("GroupingSetsClauseSegment").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Delimited::new(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            one_of(vec![
                                Ref::new("WithCubeRollupClauseSegment").to_matchable(),
                                Ref::new("GroupingSetsClauseSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WithCubeRollupClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::WithCubeRollupClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("WITH").to_matchable(),
                    one_of(vec![
                        Ref::keyword("CUBE").to_matchable(),
                        Ref::keyword("ROLLUP").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SortByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::SortByClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SORT").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Delimited::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("NumericLiteralSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            one_of(vec![
                                Ref::keyword("ASC").to_matchable(),
                                Ref::keyword("DESC").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("NULLS").to_matchable(),
                                one_of(vec![
                                    Ref::keyword("FIRST").to_matchable(),
                                    Ref::keyword("LAST").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.terminators = vec![
                            Ref::keyword("LIMIT").to_matchable(),
                            Ref::keyword("HAVING").to_matchable(),
                            Ref::keyword("QUALIFY").to_matchable(),
                            Ref::keyword("WINDOW").to_matchable(),
                            Ref::new("FrameClauseUnitGrammar").to_matchable(),
                            Ref::keyword("SEPARATOR").to_matchable(),
                        ];
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SamplingExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::SampleExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("TABLESAMPLE").to_matchable(),
                    one_of(vec![
                        Bracketed::new(vec![
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            one_of(vec![
                                Ref::keyword("PERCENT").to_matchable(),
                                Ref::keyword("ROWS").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Bracketed::new(vec![
                            Ref::keyword("BUCKET").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            Ref::keyword("OUT").to_matchable(),
                            Ref::keyword("OF").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LateralViewClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::LateralViewClause, |_dialect| {
                Sequence::new(vec![
                    Ref::new("CommaSegment").optional().to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::keyword("LATERAL").to_matchable(),
                    Ref::keyword("VIEW").optional().to_matchable(),
                    Ref::keyword("OUTER").optional().to_matchable(),
                    Ref::new("FunctionSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("AS").optional().to_matchable(),
                                Delimited::new(vec![
                                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("AS").optional().to_matchable(),
                            Delimited::new(vec![
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PivotClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::PivotClause, |_dialect| {
                Sequence::new(vec![
                    MetaSegment::indent().to_matchable(),
                    Ref::keyword("PIVOT").to_matchable(),
                    Bracketed::new(vec![
                        MetaSegment::indent().to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("BaseExpressionElementGrammar").to_matchable(),
                                Ref::new("AliasExpressionSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("FOR").to_matchable(),
                        optionally_bracketed(vec![
                            one_of(vec![
                                Ref::new("SingleIdentifierGrammar").to_matchable(),
                                Delimited::new(vec![
                                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("IN").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    one_of(vec![
                                        Bracketed::new(vec![
                                            Delimited::new(vec![
                                                Ref::new("ExpressionSegment").to_matchable(),
                                            ])
                                            .to_matchable(),
                                        ])
                                        .config(|this| {
                                            this.parse_mode(ParseMode::Greedy);
                                        })
                                        .to_matchable(),
                                        Delimited::new(vec![
                                            Ref::new("ExpressionSegment").to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::new("AliasExpressionSegment").optional().to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        MetaSegment::dedent().to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnpivotClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::UnpivotClause, |_dialect| {
                Sequence::new(vec![
                    MetaSegment::indent().to_matchable(),
                    Ref::keyword("UNPIVOT").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("INCLUDE").to_matchable(),
                            Ref::keyword("EXCLUDE").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("NULLS").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Bracketed::new(vec![
                        one_of(vec![
                            Ref::new("SingleValueColumnUnpivotSegment").to_matchable(),
                            Ref::new("MultiValueColumnUnpivotSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SingleValueColumnUnpivotSegment".into(),
            NodeMatcher::new(SyntaxKind::UnpivotSingleColumn, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::keyword("FOR").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::keyword("IN").to_matchable(),
                    Bracketed::new(vec![
                        MetaSegment::indent().to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                                Ref::new("AliasExpressionSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.parse_mode(ParseMode::Greedy);
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MultiValueColumnUnpivotSegment".into(),
            NodeMatcher::new(SyntaxKind::UnpivotMultiColumn, |_dialect| {
                Sequence::new(vec![
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("SingleIdentifierGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::keyword("FOR").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::keyword("IN").to_matchable(),
                    Bracketed::new(vec![
                        MetaSegment::indent().to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Bracketed::new(vec![
                                    MetaSegment::indent().to_matchable(),
                                    Delimited::new(vec![
                                        Ref::new("ColumnReferenceSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("AliasExpressionSegment").optional().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.parse_mode(ParseMode::Greedy);
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TransformClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::TransformClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("TRANSFORM").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("SingleIdentifierGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.parse_mode(ParseMode::Greedy);
                    })
                    .to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("RowFormatClauseSegment").optional().to_matchable(),
                    Ref::keyword("USING").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                AnyNumberOf::new(vec![
                                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("RowFormatClauseSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ExplainStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ExplainStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("EXPLAIN").to_matchable(),
                    one_of(vec![
                        Ref::keyword("EXTENDED").to_matchable(),
                        Ref::keyword("CODEGEN").to_matchable(),
                        Ref::keyword("COST").to_matchable(),
                        Ref::keyword("FORMATTED").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("StatementSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AddFileSegment".into(),
            NodeMatcher::new(SyntaxKind::AddFileStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ADD").to_matchable(),
                    Ref::keyword("FILE").to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FileLiteralSegment".into(),
            NodeMatcher::new(SyntaxKind::FileLiteral, |_dialect| {
                one_of(vec![
                    TypedParser::new(SyntaxKind::FileLiteral, SyntaxKind::Literal).to_matchable(),
                    Sequence::new(vec![
                        Ref::new("SlashSegment").optional().to_matchable(),
                        Delimited::new(vec![
                            Delimited::new(vec![
                                TypedParser::new(SyntaxKind::Word, SyntaxKind::PathSegment)
                                    .to_matchable(),
                            ])
                            .config(|this| {
                                this.delimiter(Ref::new("DotSegment"));
                            })
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.disallow_gaps();
                            this.delimiter(Ref::new("SlashSegment"));
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AddJarSegment".into(),
            NodeMatcher::new(SyntaxKind::AddJarStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ADD").to_matchable(),
                    Ref::keyword("JAR").to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AnalyzeTableSegment".into(),
            NodeMatcher::new(SyntaxKind::AnalyzeTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ANALYZE").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("TABLE").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                            Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                            Ref::keyword("COMPUTE").to_matchable(),
                            Ref::keyword("STATISTICS").to_matchable(),
                            one_of(vec![
                                Ref::keyword("NOSCAN").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("FOR").to_matchable(),
                                    Ref::keyword("COLUMNS").to_matchable(),
                                    optionally_bracketed(vec![
                                        Delimited::new(vec![
                                            Ref::new("ColumnReferenceSegment").to_matchable(),
                                        ])
                                        .to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("TABLES").to_matchable(),
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::keyword("FROM").to_matchable(),
                                    Ref::keyword("IN").to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("DatabaseReferenceSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Ref::keyword("COMPUTE").to_matchable(),
                            Ref::keyword("STATISTICS").to_matchable(),
                            Ref::keyword("NOSCAN").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CacheTableSegment".into(),
            NodeMatcher::new(SyntaxKind::CacheTable, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CACHE").to_matchable(),
                    Ref::keyword("LAZY").optional().to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Ref::new("OptionsGrammar").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").optional().to_matchable(),
                        Ref::new("SelectableGrammar").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ClearCacheSegment".into(),
            NodeMatcher::new(SyntaxKind::ClearCache, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CLEAR").to_matchable(),
                    Ref::keyword("CACHE").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DescribeStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DescribeStatement, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::keyword("DESCRIBE").to_matchable(),
                        Ref::keyword("DESC").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DescribeObjectGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ListFileSegment".into(),
            NodeMatcher::new(SyntaxKind::ListFileStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("LIST").to_matchable(),
                    Ref::keyword("FILE").to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ListJarSegment".into(),
            NodeMatcher::new(SyntaxKind::ListJarStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("LIST").to_matchable(),
                    Ref::keyword("JAR").to_matchable(),
                    AnyNumberOf::new(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RefreshStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::RefreshStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("REFRESH").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("TABLE").optional().to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("FUNCTION").to_matchable(),
                            Ref::new("FunctionNameSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ResetStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ResetStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("RESET").to_matchable(),
                    Delimited::new(vec![Ref::new("SingleIdentifierGrammar").to_matchable()])
                        .config(|this| {
                            this.optional();
                            this.delimiter(Ref::new("DotSegment"));
                        })
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SetStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SET").to_matchable(),
                    Ref::new("SQLConfPropertiesSegment")
                        .optional()
                        .to_matchable(),
                    one_of(vec![
                        Ref::new("PropertyListGrammar").to_matchable(),
                        Ref::new("PropertyNameSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ShowStatement".into(),
            NodeMatcher::new(SyntaxKind::ShowStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SHOW").to_matchable(),
                    Ref::new("ShowObjectGrammar").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UncacheTableSegment".into(),
            NodeMatcher::new(SyntaxKind::UncacheTable, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UNCACHE").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StatementSegment".into(),
            NodeMatcher::new(SyntaxKind::Statement, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("StatementSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("AlterDatabaseStatementSegment").to_matchable(),
                        Ref::new("AlterTableStatementSegment").to_matchable(),
                        Ref::new("AlterViewStatementSegment").to_matchable(),
                        Ref::new("CreateTableStatementSegment").to_matchable(),
                        Ref::new("MsckRepairTableStatementSegment").to_matchable(),
                        Ref::new("UseDatabaseStatementSegment").to_matchable(),
                        Ref::new("AddFileSegment").to_matchable(),
                        Ref::new("AddJarSegment").to_matchable(),
                        Ref::new("AnalyzeTableSegment").to_matchable(),
                        Ref::new("CacheTableSegment").to_matchable(),
                        Ref::new("ClearCacheSegment").to_matchable(),
                        Ref::new("ListFileSegment").to_matchable(),
                        Ref::new("ListJarSegment").to_matchable(),
                        Ref::new("RefreshStatementSegment").to_matchable(),
                        Ref::new("ResetStatementSegment").to_matchable(),
                        Ref::new("SetStatementSegment").to_matchable(),
                        Ref::new("ShowStatement").to_matchable(),
                        Ref::new("UncacheTableSegment").to_matchable(),
                        Ref::new("InsertOverwriteDirectorySegment").to_matchable(),
                        Ref::new("InsertOverwriteDirectoryHiveFmtSegment").to_matchable(),
                        Ref::new("LoadDataSegment").to_matchable(),
                        Ref::new("ClusterByClauseSegment").to_matchable(),
                        Ref::new("DistributeByClauseSegment").to_matchable(),
                        Ref::new("VacuumStatementSegment").to_matchable(),
                        Ref::new("DescribeHistoryStatementSegment").to_matchable(),
                        Ref::new("DescribeDetailStatementSegment").to_matchable(),
                        Ref::new("GenerateManifestFileStatementSegment").to_matchable(),
                        Ref::new("ConvertToDeltaStatementSegment").to_matchable(),
                        Ref::new("RestoreTableStatementSegment").to_matchable(),
                        Ref::new("ConstraintStatementSegment").to_matchable(),
                        Ref::new("ApplyChangesIntoStatementSegment").to_matchable(),
                        Ref::new("CreateWidgetStatementSegment").to_matchable(),
                        Ref::new("RemoveWidgetStatementSegment").to_matchable(),
                        Ref::new("ReplaceTableStatementSegment").to_matchable(),
                        Ref::new("SetVariableStatementSegment").to_matchable(),
                    ]),
                    None,
                    None,
                    Some(vec![
                        Ref::new("TransactionStatementSegment").to_matchable(),
                        Ref::new("CreateSchemaStatementSegment").to_matchable(),
                        Ref::new("SetSchemaStatementSegment").to_matchable(),
                        Ref::new("CreateModelStatementSegment").to_matchable(),
                        Ref::new("DropModelStatementSegment").to_matchable(),
                    ]),
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "JoinClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::JoinClause, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::new("JoinTypeKeywords").optional().to_matchable(),
                        Ref::new("JoinKeywordsGrammar").to_matchable(),
                        MetaSegment::indent().to_matchable(),
                        Ref::new("FromExpressionElementSegment").to_matchable(),
                        MetaSegment::dedent().to_matchable(),
                        Conditional::new(MetaSegment::indent())
                            .indented_using_on()
                            .to_matchable(),
                        one_of(vec![
                            Ref::new("JoinOnConditionSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("USING").to_matchable(),
                                Conditional::new(MetaSegment::indent()).to_matchable(),
                                Bracketed::new(vec![
                                    Delimited::new(vec![
                                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .config(|this| {
                                    this.parse_mode(ParseMode::Greedy);
                                })
                                .to_matchable(),
                                Conditional::new(MetaSegment::dedent()).to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Conditional::new(MetaSegment::dedent())
                            .indented_using_on()
                            .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::new("NaturalJoinKeywordsGrammar").to_matchable(),
                        Ref::new("JoinKeywordsGrammar").to_matchable(),
                        MetaSegment::indent().to_matchable(),
                        Ref::new("FromExpressionElementSegment").to_matchable(),
                        MetaSegment::dedent().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AliasExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::AliasExpression, |_dialect| {
                Sequence::new(vec![
                    MetaSegment::indent().to_matchable(),
                    Ref::new("AsAliasOperatorSegment").optional().to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::new("SingleIdentifierGrammar")
                                .optional()
                                .to_matchable(),
                            Bracketed::new(vec![
                                Ref::new("SingleIdentifierListSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                    ])
                    .config(|this| {
                        this.exclude = Some(
                            one_of(vec![
                                Ref::keyword("LATERAL").to_matchable(),
                                Ref::new("JoinTypeKeywords").to_matchable(),
                                Ref::keyword("WINDOW").to_matchable(),
                                Ref::keyword("PIVOT").to_matchable(),
                                Ref::keyword("KEYS").to_matchable(),
                                Ref::keyword("FROM").to_matchable(),
                            ])
                            .to_matchable(),
                        );
                    })
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ValuesClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::ValuesClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("VALUES").to_matchable(),
                    Delimited::new(vec![
                        one_of(vec![
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::keyword("NULL").to_matchable(),
                                    Ref::new("ExpressionSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.parse_mode(ParseMode::Greedy);
                            })
                            .to_matchable(),
                            Ref::keyword("NULL").to_matchable(),
                            Ref::new("ExpressionSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.exclude = Some(
                                one_of(vec![Ref::keyword("VALUES").to_matchable()]).to_matchable(),
                            );
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("AliasExpressionSegment")
                        .exclude(one_of(vec![
                            Ref::keyword("LIMIT").to_matchable(),
                            Ref::keyword("ORDER").to_matchable(),
                        ]))
                        .optional()
                        .to_matchable(),
                    Ref::new("OrderByClauseSegment").optional().to_matchable(),
                    Ref::new("LimitClauseSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TableExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::TableExpression, |_dialect| {
                one_of(vec![
                    Ref::new("ValuesClauseSegment").to_matchable(),
                    Ref::new("BareFunctionSegment").to_matchable(),
                    Ref::new("FunctionSegment").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::new("FileReferenceSegment").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        one_of(vec![
                            Ref::new("AtSignLiteralSegment").to_matchable(),
                            Sequence::new(vec![
                                MetaSegment::indent().to_matchable(),
                                one_of(vec![
                                    Ref::new("TimestampAsOfGrammar").to_matchable(),
                                    Ref::new("VersionAsOfGrammar").to_matchable(),
                                ])
                                .to_matchable(),
                                MetaSegment::dedent().to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Bracketed::new(vec![Ref::new("SelectableGrammar").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FileReferenceSegment".into(),
            NodeMatcher::new(SyntaxKind::FileReference, |_dialect| {
                Sequence::new(vec![
                    Ref::new("DataSourcesV2FileTypeGrammar").to_matchable(),
                    Ref::new("DotSegment").to_matchable(),
                    Ref::new("BackQuotedIdentifierSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FromExpressionElementSegment".into(),
            NodeMatcher::new(SyntaxKind::FromExpressionElement, |_dialect| {
                Sequence::new(vec![
                    Ref::new("PreTableFunctionKeywordsGrammar")
                        .optional()
                        .to_matchable(),
                    optionally_bracketed(vec![Ref::new("TableExpressionSegment").to_matchable()])
                        .to_matchable(),
                    Ref::new("SamplingExpressionSegment")
                        .optional()
                        .to_matchable(),
                    Ref::new("AliasExpressionSegment")
                        .exclude(one_of(vec![
                            Ref::new("FromClauseTerminatorGrammar").to_matchable(),
                            Ref::new("JoinLikeClauseGrammar").to_matchable(),
                        ]))
                        .optional()
                        .to_matchable(),
                    Ref::new("PostTableExpressionGrammar")
                        .optional()
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "PropertyNameSegment".into(),
            NodeMatcher::new(SyntaxKind::PropertyNameIdentifier, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Delimited::new(vec![
                            Ref::new("PropertiesNakedIdentifierSegment").to_matchable(),
                        ])
                        .config(|this| {
                            this.disallow_gaps();
                            this.delimiter(Ref::new("DotSegment"));
                        })
                        .to_matchable(),
                        Ref::new("SingleIdentifierGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MergeUpdateClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::MergeUpdateClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UPDATE").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::new("WildcardIdentifierSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            MetaSegment::indent().to_matchable(),
                            Ref::new("SetClauseListSegment").to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MergeInsertClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::MergeInsertClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INSERT").to_matchable(),
                    one_of(vec![
                        Ref::new("WildcardIdentifierSegment").to_matchable(),
                        Sequence::new(vec![
                            MetaSegment::indent().to_matchable(),
                            Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                            MetaSegment::dedent().to_matchable(),
                            Ref::new("ValuesClauseSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UpdateStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::UpdateStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("UPDATE").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Ref::new("FileReferenceSegment").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("AliasExpressionSegment")
                        .exclude(Ref::keyword("SET"))
                        .optional()
                        .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                    Ref::new("SetClauseListSegment").to_matchable(),
                    Ref::new("WhereClauseSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IntervalLiteralSegment".into(),
            NodeMatcher::new(SyntaxKind::IntervalLiteral, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SignedSegmentGrammar").optional().to_matchable(),
                    one_of(vec![
                        Ref::new("NumericLiteralSegment").to_matchable(),
                        Ref::new("SignedQuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("DatetimeUnitSegment").to_matchable(),
                    Ref::keyword("TO").optional().to_matchable(),
                    Ref::new("DatetimeUnitSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IntervalExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::IntervalExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INTERVAL").to_matchable(),
                    one_of(vec![
                        AnyNumberOf::new(vec![Ref::new("IntervalLiteralSegment").to_matchable()])
                            .to_matchable(),
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "VacuumStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::VacuumStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("VACUUM").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileReferenceSegment").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RETAIN").to_matchable(),
                            Ref::new("NumericLiteralSegment").to_matchable(),
                            Ref::new("DatetimeUnitSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DRY").to_matchable(),
                            Ref::keyword("RUN").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DescribeHistoryStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DescribeHistoryStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DESCRIBE").to_matchable(),
                    Ref::keyword("HISTORY").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileReferenceSegment").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("LimitClauseSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DescribeDetailStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::DescribeDetailStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("DESCRIBE").to_matchable(),
                    Ref::keyword("DETAIL").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileReferenceSegment").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "GenerateManifestFileStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::GenerateManifestFileStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("GENERATE").to_matchable(),
                    StringParser::new("symlink_format_manifest", SyntaxKind::SymlinkFormatManifest)
                        .to_matchable(),
                    Ref::keyword("FOR").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileReferenceSegment").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ConvertToDeltaStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ConvertToDeltaStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CONVERT").to_matchable(),
                    Ref::keyword("TO").to_matchable(),
                    Ref::keyword("DELTA").to_matchable(),
                    Ref::new("FileReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("NO").to_matchable(),
                        Ref::keyword("STATISTICS").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("PartitionSpecGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RestoreTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::RestoreTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("RESTORE").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    one_of(vec![
                        Ref::new("QuotedLiteralSegment").to_matchable(),
                        Ref::new("FileReferenceSegment").to_matchable(),
                        Ref::new("TableReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("TO").to_matchable(),
                    one_of(vec![
                        Ref::new("TimestampAsOfGrammar").to_matchable(),
                        Ref::new("VersionAsOfGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ConstraintStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ConstraintStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CONSTRAINT").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                    Ref::keyword("EXPECT").to_matchable(),
                    Bracketed::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                        .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ON").to_matchable(),
                        Ref::keyword("VIOLATION").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("FAIL").to_matchable(),
                            Ref::keyword("UPDATE").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            Ref::keyword("ROW").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ApplyChangesIntoStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::ApplyChangesIntoStatement, |_dialect| {
                Sequence::new(vec![
                    Sequence::new(vec![
                        Ref::keyword("APPLY").to_matchable(),
                        Ref::keyword("CHANGES").to_matchable(),
                        Ref::keyword("INTO").to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    Ref::new("TableExpressionSegment").to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                    Ref::new("FromClauseSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("KEYS").to_matchable(),
                        MetaSegment::indent().to_matchable(),
                        Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                        MetaSegment::dedent().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("IGNORE").to_matchable(),
                        Ref::keyword("NULL").to_matchable(),
                        Ref::keyword("UPDATES").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("WhereClauseSegment").optional().to_matchable(),
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::keyword("APPLY").to_matchable(),
                            Ref::keyword("AS").to_matchable(),
                            one_of(vec![
                                Ref::keyword("DELETE").to_matchable(),
                                Ref::keyword("TRUNCATE").to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("WHEN").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("EqualsSegment").to_matchable(),
                            Ref::new("QuotedLiteralSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times(2);
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("SEQUENCE").to_matchable(),
                        Ref::keyword("BY").to_matchable(),
                        Ref::new("ColumnReferenceSegment").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("COLUMNS").to_matchable(),
                        one_of(vec![
                            Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                                .to_matchable(),
                            Sequence::new(vec![
                                Ref::new("StarSegment").to_matchable(),
                                Ref::keyword("EXCEPT").to_matchable(),
                                Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("STORED").to_matchable(),
                        Ref::keyword("AS").to_matchable(),
                        Ref::keyword("SCD").to_matchable(),
                        Ref::keyword("TYPE").to_matchable(),
                        Ref::new("NumericLiteralSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("TRACK").to_matchable(),
                        Ref::keyword("HISTORY").to_matchable(),
                        Ref::keyword("ON").to_matchable(),
                        one_of(vec![
                            Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                                .to_matchable(),
                            Sequence::new(vec![
                                Ref::new("StarSegment").to_matchable(),
                                Ref::keyword("EXCEPT").to_matchable(),
                                Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WildcardExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::WildcardExpression, |_dialect| {
                {
                    let dialect = super::ansi::raw_dialect();
                    dialect
                        .grammar("WildcardExpressionSegment")
                        .match_grammar(&dialect)
                        .unwrap()
                }
                .copy(
                    Some(vec![
                        Ref::new("ExceptClauseSegment").optional().to_matchable(),
                    ]),
                    None,
                    None,
                    None,
                    vec![],
                    false,
                )
            })
            .to_matchable()
            .into(),
        ),
        (
            "ExceptClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectExceptClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("EXCEPT").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SelectClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SELECT").to_matchable(),
                    one_of(vec![
                        Ref::new("TransformClauseSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::new("SelectClauseModifierSegment")
                                .optional()
                                .to_matchable(),
                            MetaSegment::indent().to_matchable(),
                            Delimited::new(vec![
                                Ref::new("SelectClauseElementSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.allow_trailing();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .config(|this| {
                    this.parse_mode(ParseMode::GreedyOnceStarted);
                    this.terminators =
                        vec![Ref::new("SelectClauseTerminatorGrammar").to_matchable()];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UsingClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::UsingClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("USING").to_matchable(),
                    Ref::new("DataSourceFormatSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DataSourceFormatSegment".into(),
            NodeMatcher::new(SyntaxKind::DataSourceFormat, |_dialect| {
                one_of(vec![
                    Ref::new("FileFormatGrammar").to_matchable(),
                    Ref::keyword("JDBC").to_matchable(),
                    Ref::new("ObjectReferenceSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IcebergTransformationSegment".into(),
            NodeMatcher::new(SyntaxKind::IcebergTransformation, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("YEARS").to_matchable(),
                            Ref::keyword("MONTHS").to_matchable(),
                            Ref::keyword("DAYS").to_matchable(),
                            Ref::keyword("DATE").to_matchable(),
                            Ref::keyword("HOURS").to_matchable(),
                            Ref::keyword("DATE_HOUR").to_matchable(),
                        ])
                        .to_matchable(),
                        Bracketed::new(vec![Ref::new("ColumnReferenceSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("BUCKET").to_matchable(),
                            Ref::keyword("TRUNCATE").to_matchable(),
                        ])
                        .to_matchable(),
                        Bracketed::new(vec![
                            Sequence::new(vec![
                                Ref::new("NumericLiteralSegment").to_matchable(),
                                Ref::new("CommaSegment").to_matchable(),
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FrameClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::FrameClause, |_dialect| {
                Sequence::new(vec![
                    Ref::new("FrameClauseUnitGrammar").to_matchable(),
                    one_of(vec![
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("CURRENT").to_matchable(),
                                Ref::keyword("ROW").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::new("NumericLiteralSegment").to_matchable(),
                                    Ref::keyword("UNBOUNDED").to_matchable(),
                                    Ref::new("IntervalExpressionSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                one_of(vec![
                                    Ref::keyword("PRECEDING").to_matchable(),
                                    Ref::keyword("FOLLOWING").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("BETWEEN").to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("CURRENT").to_matchable(),
                                    Ref::keyword("ROW").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::new("NumericLiteralSegment").to_matchable(),
                                        Ref::keyword("UNBOUNDED").to_matchable(),
                                        Ref::new("IntervalExpressionSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    one_of(vec![
                                        Ref::keyword("PRECEDING").to_matchable(),
                                        Ref::keyword("FOLLOWING").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("AND").to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("CURRENT").to_matchable(),
                                    Ref::keyword("ROW").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::new("NumericLiteralSegment").to_matchable(),
                                        Ref::keyword("UNBOUNDED").to_matchable(),
                                        Ref::new("IntervalExpressionSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    one_of(vec![
                                        Ref::keyword("PRECEDING").to_matchable(),
                                        Ref::keyword("FOLLOWING").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetVariableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SetVariableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SET").to_matchable(),
                    one_of(vec![
                        Ref::keyword("VAR").to_matchable(),
                        Ref::keyword("VARIABLE").to_matchable(),
                    ])
                    .to_matchable(),
                    optionally_bracketed(vec![
                        Delimited::new(vec![Ref::new("SingleIdentifierGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("EqualsSegment").to_matchable(),
                    one_of(vec![
                        Ref::keyword("DEFAULT").to_matchable(),
                        optionally_bracketed(vec![Ref::new("ExpressionSegment").to_matchable()])
                            .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
    ]);

    sparksql_dialect
}
