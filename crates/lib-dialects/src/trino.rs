use sqruff_lib_core::dialects::Dialect;
use sqruff_lib_core::dialects::init::DialectKind;
use sqruff_lib_core::dialects::syntax::SyntaxKind;
use sqruff_lib_core::helpers::{Config, ToMatchable};
use sqruff_lib_core::parser::grammar::anyof::{AnyNumberOf, one_of, optionally_bracketed};
use sqruff_lib_core::parser::grammar::delimited::Delimited;
use sqruff_lib_core::parser::grammar::sequence::{Bracketed, Sequence};
use sqruff_lib_core::parser::grammar::{Anything, Nothing, Ref};
use sqruff_lib_core::parser::lexer::Matcher;
use sqruff_lib_core::parser::matchable::MatchableTrait;
use sqruff_lib_core::parser::node_matcher::NodeMatcher;
use sqruff_lib_core::parser::parsers::{StringParser, TypedParser};
use sqruff_lib_core::parser::segments::meta::MetaSegment;

use super::trino_keywords::{TRINO_RESERVED_KEYWORDS, TRINO_UNRESERVED_KEYWORDS};

pub fn dialect() -> Dialect {
    raw_dialect().config(|this| this.expand())
}

pub fn raw_dialect() -> Dialect {
    let ansi_dialect = super::ansi::raw_dialect();
    let mut trino_dialect = ansi_dialect.clone();
    trino_dialect.name = DialectKind::Trino;

    trino_dialect.sets_mut("bare_functions").extend([
        "current_date",
        "current_time",
        "current_timestamp",
        "localtime",
        "localtimestamp",
    ]);

    trino_dialect.sets_mut("unreserved_keywords").clear();

    trino_dialect.update_keywords_set_from_multiline_string(
        "unreserved_keywords",
        TRINO_UNRESERVED_KEYWORDS,
    );

    trino_dialect.sets_mut("reserved_keywords").clear();

    trino_dialect
        .update_keywords_set_from_multiline_string("reserved_keywords", TRINO_RESERVED_KEYWORDS);

    trino_dialect.insert_lexer_matchers(
        vec![
            Matcher::string("right_arrow", r#"->"#, SyntaxKind::RightArrow),
            Matcher::string("fat_right_arrow", r#"=>"#, SyntaxKind::FatRightArrow),
        ],
        "like_operator",
    );

    trino_dialect.add([
        (
            "RightArrowOperator".into(),
            StringParser::new("->", SyntaxKind::BinaryOperator)
                .to_matchable()
                .into(),
        ),
        (
            "LambdaArrowSegment".into(),
            StringParser::new("->", SyntaxKind::LambdaArrow)
                .to_matchable()
                .into(),
        ),
        (
            "ExecuteArrowSegment".into(),
            StringParser::new("=>", SyntaxKind::ExecuteArrow)
                .to_matchable()
                .into(),
        ),
        (
            "StartAngleBracketSegment".into(),
            StringParser::new("<", SyntaxKind::StartAngleBracket)
                .to_matchable()
                .into(),
        ),
        (
            "EndAngleBracketSegment".into(),
            StringParser::new(">", SyntaxKind::EndAngleBracket)
                .to_matchable()
                .into(),
        ),
        (
            "FormatJsonEncodingGrammar".into(),
            Sequence::new(vec![
                Ref::keyword("FORMAT").to_matchable(),
                Ref::keyword("JSON").to_matchable(),
                Sequence::new(vec![
                    Ref::keyword("ENCODING").to_matchable(),
                    one_of(vec![
                        Ref::keyword("UTF8").to_matchable(),
                        Ref::keyword("UTF16").to_matchable(),
                        Ref::keyword("UTF32").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable()
            .into(),
        ),
    ]);

    trino_dialect.update_bracket_sets(
        "angle_bracket_pairs",
        vec![(
            "angle",
            "StartAngleBracketSegment",
            "EndAngleBracketSegment",
            false,
        )],
    );

    trino_dialect.patch_lexer_matchers(vec![Matcher::regex(
        "double_quote",
        r#""([^"]|"")*""#,
        SyntaxKind::DoubleQuote,
    )]);

    trino_dialect.replace_grammar(
        "DateTimeLiteralGrammar",
        one_of(vec![
            Sequence::new(vec![
                one_of(vec![
                    Ref::keyword("DATE").to_matchable(),
                    Ref::keyword("TIME").to_matchable(),
                    Ref::keyword("TIMESTAMP").to_matchable(),
                ])
                .to_matchable(),
                TypedParser::new(SyntaxKind::SingleQuote, SyntaxKind::DateConstructorLiteral)
                    .to_matchable(),
            ])
            .to_matchable(),
            Ref::new("IntervalExpressionSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "LikeGrammar",
        Sequence::new(vec![Ref::keyword("LIKE").to_matchable()]).to_matchable(),
    );

    trino_dialect.replace_grammar("MLTableExpressionSegment", Nothing::new().to_matchable());

    trino_dialect.replace_grammar(
        "FromClauseTerminatorGrammar",
        one_of(vec![
            Ref::keyword("WHERE").to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("GROUP").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::new("SetOperatorSegment").to_matchable(),
            Ref::new("WithNoSchemaBindingClauseSegment").to_matchable(),
            Ref::new("WithDataClauseSegment").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "OrderByClauseTerminators",
        one_of(vec![
            Ref::keyword("LIMIT").to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::new("FrameClauseUnitGrammar").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "SelectClauseTerminatorGrammar",
        one_of(vec![
            Ref::keyword("FROM").to_matchable(),
            Ref::keyword("WHERE").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Ref::new("SetOperatorSegment").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "WhereClauseTerminatorGrammar",
        one_of(vec![
            Ref::keyword("LIMIT").to_matchable(),
            Sequence::new(vec![
                Ref::keyword("GROUP").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "HavingClauseTerminatorGrammar",
        one_of(vec![
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "GroupByClauseTerminatorGrammar",
        one_of(vec![
            Sequence::new(vec![
                Ref::keyword("ORDER").to_matchable(),
                Ref::keyword("BY").to_matchable(),
            ])
            .to_matchable(),
            Ref::keyword("LIMIT").to_matchable(),
            Ref::keyword("HAVING").to_matchable(),
            Ref::keyword("WINDOW").to_matchable(),
            Ref::keyword("FETCH").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "Expression_A_Unary_Operator_Grammar",
        one_of(vec![
            Ref::new("SignedSegmentGrammar")
                .exclude(Sequence::new(vec![
                    Ref::new("QualifiedNumericLiteralSegment").to_matchable(),
                ]))
                .to_matchable(),
            Ref::new("TildeSegment").to_matchable(),
            Ref::new("NotOperatorGrammar").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "PostFunctionGrammar",
        ansi_dialect.grammar("PostFunctionGrammar").copy(
            Some(vec![
                Ref::new("WithinGroupClauseSegment").to_matchable(),
                Ref::new("WithOrdinalityClauseSegment").to_matchable(),
            ]),
            None,
            None,
            None,
            vec![],
            false,
        ),
    );

    trino_dialect.replace_grammar(
        "FunctionContentsGrammar",
        AnyNumberOf::new(vec![
            Ref::new("ExpressionSegment").to_matchable(),
            Sequence::new(vec![
                Ref::new("ExpressionSegment").to_matchable(),
                Ref::keyword("AS").to_matchable(),
                Ref::new("DatatypeSegment").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::new("TrimParametersGrammar").to_matchable(),
                Ref::new("ExpressionSegment")
                    .exclude(Ref::keyword("FROM"))
                    .optional()
                    .to_matchable(),
                Ref::keyword("FROM").to_matchable(),
                Ref::new("ExpressionSegment").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::new("DatetimeUnitSegment").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                ])
                .to_matchable(),
                Ref::keyword("FROM").to_matchable(),
                Ref::new("ExpressionSegment").to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::keyword("DISTINCT").optional().to_matchable(),
                one_of(vec![
                    Ref::new("StarSegment").to_matchable(),
                    Delimited::new(vec![
                        Ref::new("FunctionContentsExpressionGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable(),
            Ref::new("OrderByClauseSegment").to_matchable(),
            Sequence::new(vec![
                one_of(vec![
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::new("ColumnReferenceSegment").to_matchable(),
                ])
                .to_matchable(),
                Ref::keyword("IN").to_matchable(),
                one_of(vec![
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::new("ColumnReferenceSegment").to_matchable(),
                ])
                .to_matchable(),
            ])
            .to_matchable(),
            Sequence::new(vec![
                Ref::new("ExpressionSegment").to_matchable(),
                Ref::new("FormatJsonEncodingGrammar")
                    .optional()
                    .to_matchable(),
                Ref::new("CommaSegment").to_matchable(),
                Ref::new("ExpressionSegment").to_matchable(),
                one_of(vec![
                    Sequence::new(vec![
                        Ref::keyword("WITHOUT").to_matchable(),
                        Ref::keyword("ARRAY").optional().to_matchable(),
                        Ref::keyword("WRAPPER").to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        one_of(vec![
                            Ref::keyword("CONDITIONAL").to_matchable(),
                            Ref::keyword("UNCONDITIONAL").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                        Ref::keyword("ARRAY").optional().to_matchable(),
                        Ref::keyword("WRAPPER").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.optional();
                })
                .to_matchable(),
            ])
            .to_matchable(),
            Ref::new("IgnoreRespectNullsGrammar").to_matchable(),
            Ref::new("IndexColumnDefinitionSegment").to_matchable(),
            Ref::new("EmptyStructLiteralSegment").to_matchable(),
            Ref::new("ListaggOverflowClauseSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "BinaryOperatorGrammar",
        one_of(vec![
            Ref::new("ArithmeticBinaryOperatorGrammar").to_matchable(),
            Ref::new("StringBinaryOperatorGrammar").to_matchable(),
            Ref::new("BooleanBinaryOperatorGrammar").to_matchable(),
            Ref::new("ComparisonOperatorGrammar").to_matchable(),
            Ref::new("RightArrowOperator").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "AccessorGrammar",
        AnyNumberOf::new(vec![
            Ref::new("ArrayAccessorSegment").to_matchable(),
            Ref::new("SemiStructuredAccessorSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar(
        "QuotedIdentifierSegment",
        TypedParser::new(SyntaxKind::DoubleQuote, SyntaxKind::QuotedIdentifier).to_matchable(),
    );

    trino_dialect.replace_grammar(
        "FunctionContentsExpressionGrammar",
        one_of(vec![
            Ref::new("LambdaExpressionSegment").to_matchable(),
            Ref::new("ExpressionSegment").to_matchable(),
        ])
        .to_matchable(),
    );

    trino_dialect.replace_grammar("TemporaryTransientGrammar", Nothing::new().to_matchable());

    trino_dialect.replace_grammar("PrimaryKeyGrammar", Nothing::new().to_matchable());

    trino_dialect.replace_grammar("ForeignKeyGrammar", Nothing::new().to_matchable());

    trino_dialect.replace_grammar("UniqueKeyGrammar", Nothing::new().to_matchable());

    trino_dialect.replace_grammar("TemporaryGrammar", Nothing::new().to_matchable());

    trino_dialect.add([
        (
            "PrimitiveTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::PrimitiveType, |_dialect| {
                one_of(vec![
                    Ref::keyword("BOOLEAN").to_matchable(),
                    Ref::keyword("TINYINT").to_matchable(),
                    Ref::keyword("SMALLINT").to_matchable(),
                    Ref::keyword("INTEGER").to_matchable(),
                    Ref::keyword("INT").to_matchable(),
                    Ref::keyword("BIGINT").to_matchable(),
                    Ref::keyword("REAL").to_matchable(),
                    Ref::keyword("DOUBLE").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("DECIMAL").to_matchable(),
                        Ref::new("BracketedArguments").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("CHAR").to_matchable(),
                            Ref::keyword("VARCHAR").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("BracketedArguments").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::keyword("VARBINARY").to_matchable(),
                    Ref::keyword("JSON").to_matchable(),
                    Ref::keyword("DATE").to_matchable(),
                    Ref::new("TimeWithTZGrammar").to_matchable(),
                    Ref::keyword("IPADDRESS").to_matchable(),
                    Ref::keyword("UUID").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "DatatypeSegment".into(),
            NodeMatcher::new(SyntaxKind::DataType, |_dialect| {
                one_of(vec![
                    Ref::new("PrimitiveTypeSegment").to_matchable(),
                    Ref::new("ArrayTypeSegment").to_matchable(),
                    Ref::new("MapTypeSegment").to_matchable(),
                    Ref::new("RowTypeSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RowTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::StructType, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ROW").to_matchable(),
                    Ref::new("RowTypeSchemaSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "RowTypeSchemaSegment".into(),
            NodeMatcher::new(SyntaxKind::StructTypeSchema, |_dialect| {
                Bracketed::new(vec![
                    Delimited::new(vec![
                        Sequence::new(vec![
                            one_of(vec![
                                Ref::new("DatatypeSegment").to_matchable(),
                                Sequence::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SemiStructuredAccessorSegment".into(),
            NodeMatcher::new(SyntaxKind::SemiStructuredExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::new("DotSegment").to_matchable(),
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::new("ArrayAccessorSegment").optional().to_matchable(),
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::new("DotSegment").to_matchable(),
                            Ref::new("SingleIdentifierGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("ArrayAccessorSegment").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "OverlapsClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::OverlapsClause, |_dialect| {
                Nothing::new().to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "UnorderedSelectStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SelectStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SelectClauseSegment").to_matchable(),
                    Ref::new("FromClauseSegment").optional().to_matchable(),
                    Ref::new("WhereClauseSegment").optional().to_matchable(),
                    Ref::new("GroupByClauseSegment").optional().to_matchable(),
                    Ref::new("HavingClauseSegment").optional().to_matchable(),
                    Ref::new("NamedWindowSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ValuesClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::ValuesClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("VALUES").to_matchable(),
                    Delimited::new(vec![Ref::new("ExpressionSegment").to_matchable()])
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "IntervalExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::IntervalExpression, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INTERVAL").to_matchable(),
                    Ref::new("QuotedLiteralSegment").to_matchable(),
                    one_of(vec![
                        Ref::keyword("YEAR").to_matchable(),
                        Ref::keyword("MONTH").to_matchable(),
                        Ref::keyword("DAY").to_matchable(),
                        Ref::keyword("HOUR").to_matchable(),
                        Ref::keyword("MINUTE").to_matchable(),
                        Ref::keyword("SECOND").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "FrameClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::FrameClause, |_dialect| {
                Sequence::new(vec![
                    Ref::new("FrameClauseUnitGrammar").to_matchable(),
                    one_of(vec![
                        one_of(vec![
                            Sequence::new(vec![
                                Ref::keyword("CURRENT").to_matchable(),
                                Ref::keyword("ROW").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::new("NumericLiteralSegment").to_matchable(),
                                    Ref::new("DateTimeLiteralGrammar").to_matchable(),
                                    Ref::keyword("UNBOUNDED").to_matchable(),
                                ])
                                .to_matchable(),
                                one_of(vec![
                                    Ref::keyword("PRECEDING").to_matchable(),
                                    Ref::keyword("FOLLOWING").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("BETWEEN").to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("CURRENT").to_matchable(),
                                    Ref::keyword("ROW").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::new("NumericLiteralSegment").to_matchable(),
                                        Ref::new("DateTimeLiteralGrammar").to_matchable(),
                                        Ref::keyword("UNBOUNDED").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    one_of(vec![
                                        Ref::keyword("PRECEDING").to_matchable(),
                                        Ref::keyword("FOLLOWING").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Ref::keyword("AND").to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("CURRENT").to_matchable(),
                                    Ref::keyword("ROW").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::new("NumericLiteralSegment").to_matchable(),
                                        Ref::new("DateTimeLiteralGrammar").to_matchable(),
                                        Ref::keyword("UNBOUNDED").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    one_of(vec![
                                        Ref::keyword("PRECEDING").to_matchable(),
                                        Ref::keyword("FOLLOWING").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetOperatorSegment".into(),
            NodeMatcher::new(SyntaxKind::SetOperator, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::keyword("UNION").to_matchable(),
                        one_of(vec![
                            Ref::keyword("DISTINCT").to_matchable(),
                            Ref::keyword("ALL").to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Ref::keyword("INTERSECT").to_matchable(),
                            Ref::keyword("EXCEPT").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::keyword("ALL").optional().to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .config(|this| {
                    this.exclude = Some(
                        Sequence::new(vec![
                            Ref::keyword("EXCEPT").to_matchable(),
                            Bracketed::new(vec![Anything::new().to_matchable()]).to_matchable(),
                        ])
                        .to_matchable(),
                    );
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "StatementSegment".into(),
            NodeMatcher::new(SyntaxKind::Statement, |_dialect| {
                one_of(vec![
                    Ref::new("AlterTableStatementSegment").to_matchable(),
                    Ref::new("AnalyzeStatementSegment").to_matchable(),
                    Ref::new("CommentOnStatementSegment").to_matchable(),
                    Ref::new("CreateFunctionStatementSegment").to_matchable(),
                    Ref::new("CreateRoleStatementSegment").to_matchable(),
                    Ref::new("CreateSchemaStatementSegment").to_matchable(),
                    Ref::new("CreateTableStatementSegment").to_matchable(),
                    Ref::new("CreateViewStatementSegment").to_matchable(),
                    Ref::new("DeleteStatementSegment").to_matchable(),
                    Ref::new("DescribeStatementSegment").to_matchable(),
                    Ref::new("DropFunctionStatementSegment").to_matchable(),
                    Ref::new("DropRoleStatementSegment").to_matchable(),
                    Ref::new("DropSchemaStatementSegment").to_matchable(),
                    Ref::new("DropTableStatementSegment").to_matchable(),
                    Ref::new("DropViewStatementSegment").to_matchable(),
                    Ref::new("ExplainStatementSegment").to_matchable(),
                    Ref::new("InsertStatementSegment").to_matchable(),
                    Ref::new("MergeStatementSegment").to_matchable(),
                    Ref::new("SelectableGrammar").to_matchable(),
                    Ref::new("SetSchemaStatementSegment").to_matchable(),
                    Ref::new("TransactionStatementSegment").to_matchable(),
                    Ref::new("UpdateStatementSegment").to_matchable(),
                    Ref::new("UseStatementSegment").to_matchable(),
                    Ref::new("SetSessionStatementSegment").to_matchable(),
                ])
                .config(|this| {
                    this.terminators = vec![Ref::new("DelimiterGrammar").to_matchable()];
                })
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AnalyzeStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AnalyzeStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ANALYZE").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("EqualsSegment").to_matchable(),
                                    Ref::new("ExpressionSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WithOrdinalityClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::WithordinalityClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("WITH").to_matchable(),
                    Ref::keyword("ORDINALITY").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "WithinGroupClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::WithingroupClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("WITHIN").to_matchable(),
                    Ref::keyword("GROUP").to_matchable(),
                    Bracketed::new(vec![Ref::new("OrderByClauseSegment").to_matchable()])
                        .to_matchable(),
                    Ref::new("FilterClauseGrammar").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ListaggOverflowClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::ListaggOverflowClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ON").to_matchable(),
                    Ref::keyword("OVERFLOW").to_matchable(),
                    one_of(vec![
                        Ref::keyword("ERROR").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("TRUNCATE").to_matchable(),
                            Ref::new("QuotedLiteralSegment").optional().to_matchable(),
                            one_of(vec![
                                Ref::keyword("WITH").to_matchable(),
                                Ref::keyword("WITHOUT").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Ref::keyword("COUNT").optional().to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::ArrayType, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ARRAY").to_matchable(),
                    Ref::new("ArrayTypeSchemaSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ArrayTypeSchemaSegment".into(),
            NodeMatcher::new(SyntaxKind::ArrayTypeSchema, |_dialect| {
                one_of(vec![
                    Bracketed::new(vec![Ref::new("DatatypeSegment").to_matchable()])
                        .config(|this| {
                            this.bracket_type("angle");
                            this.bracket_pairs_set = "angle_bracket_pairs";
                        })
                        .to_matchable(),
                    Bracketed::new(vec![Ref::new("DatatypeSegment").to_matchable()])
                        .config(|this| {
                            this.bracket_type("round");
                            this.bracket_pairs_set = "bracket_pairs";
                        })
                        .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "GroupByClauseSegment".into(),
            NodeMatcher::new(SyntaxKind::GroupbyClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("GROUP").to_matchable(),
                    Ref::keyword("BY").to_matchable(),
                    MetaSegment::indent().to_matchable(),
                    one_of(vec![
                        Ref::keyword("ALL").to_matchable(),
                        Ref::new("CubeRollupClauseSegment").to_matchable(),
                        Ref::new("GroupingSetsClauseSegment").to_matchable(),
                        Sequence::new(vec![
                            Delimited::new(vec![
                                one_of(vec![
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                    Ref::new("NumericLiteralSegment").to_matchable(),
                                    Ref::new("ExpressionSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.terminators =
                                    vec![Ref::new("GroupByClauseTerminatorGrammar").to_matchable()];
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    MetaSegment::dedent().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CommentOnStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CommentClause, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("COMMENT").to_matchable(),
                    Ref::keyword("ON").to_matchable(),
                    Sequence::new(vec![
                        one_of(vec![
                            Sequence::new(vec![
                                one_of(vec![
                                    Ref::keyword("TABLE").to_matchable(),
                                    Ref::keyword("VIEW").to_matchable(),
                                ])
                                .to_matchable(),
                                Ref::new("TableReferenceSegment").to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("COLUMN").to_matchable(),
                                Ref::new("ColumnReferenceSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("IS").to_matchable(),
                            one_of(vec![
                                Ref::new("QuotedLiteralSegment").to_matchable(),
                                Ref::keyword("NULL").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "LambdaExpressionSegment".into(),
            NodeMatcher::new(SyntaxKind::LambdaFunction, |_dialect| {
                Sequence::new(vec![
                    one_of(vec![
                        Ref::new("ParameterNameSegment").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![Ref::new("ParameterNameSegment").to_matchable()])
                                .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                    Ref::new("LambdaArrowSegment").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "CreateTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::CreateTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("CREATE").to_matchable(),
                    Ref::new("OrReplaceGrammar").optional().to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    Bracketed::new(vec![
                        Delimited::new(vec![
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::new("ColumnDefinitionSegment").to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("LIKE").to_matchable(),
                                Ref::new("TableReferenceSegment").to_matchable(),
                                Sequence::new(vec![
                                    one_of(vec![
                                        Ref::keyword("INCLUDING").to_matchable(),
                                        Ref::keyword("EXCLUDING").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::keyword("PROPERTIES").to_matchable(),
                                ])
                                .config(|this| {
                                    this.optional();
                                })
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("CommentClauseSegment").optional().to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Bracketed::new(vec![
                            Delimited::new(vec![
                                Ref::new("ParameterNameSegment").to_matchable(),
                                Ref::new("EqualsSegment").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("AS").to_matchable(),
                        optionally_bracketed(vec![Ref::new("SelectableGrammar").to_matchable()])
                            .to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("WITH").to_matchable(),
                        Ref::keyword("NO").optional().to_matchable(),
                        Ref::keyword("DATA").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "ColumnDefinitionSegment".into(),
            NodeMatcher::new(SyntaxKind::ColumnDefinition, |_dialect| {
                Sequence::new(vec![
                    Ref::new("SingleIdentifierGrammar").to_matchable(),
                    Ref::new("DatatypeSegment").to_matchable(),
                    AnyNumberOf::new(vec![
                        Sequence::new(vec![
                            Ref::keyword("NOT").to_matchable(),
                            Ref::keyword("NULL").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("CommentClauseSegment").to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("WITH").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("EqualsSegment").to_matchable(),
                                    Ref::new("ExpressionSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.max_times_per_element = Some(1);
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "TransactionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::TransactionStatement, |_dialect| {
                one_of(vec![
                    Sequence::new(vec![
                        Ref::keyword("COMMIT").to_matchable(),
                        Ref::keyword("WORK").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("ROLLBACK").to_matchable(),
                        Ref::keyword("WORK").optional().to_matchable(),
                    ])
                    .to_matchable(),
                    Sequence::new(vec![
                        Ref::keyword("START").to_matchable(),
                        Ref::keyword("TRANSACTION").to_matchable(),
                        Delimited::new(vec![
                            Sequence::new(vec![
                                Ref::keyword("ISOLATION").to_matchable(),
                                Ref::keyword("LEVEL").to_matchable(),
                                one_of(vec![
                                    Sequence::new(vec![
                                        Ref::keyword("READ").to_matchable(),
                                        Ref::keyword("UNCOMMITTED").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Sequence::new(vec![
                                        Ref::keyword("READ").to_matchable(),
                                        Ref::keyword("COMMITTED").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Sequence::new(vec![
                                        Ref::keyword("REPEATABLE").to_matchable(),
                                        Ref::keyword("READ").to_matchable(),
                                    ])
                                    .to_matchable(),
                                    Ref::keyword("SERIALIZABLE").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("READ").to_matchable(),
                                one_of(vec![
                                    Ref::keyword("ONLY").to_matchable(),
                                    Ref::keyword("WRITE").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .config(|this| {
                            this.optional();
                        })
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "InsertStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::InsertStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("INSERT").to_matchable(),
                    Ref::keyword("INTO").to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Ref::new("SelectableGrammar").to_matchable(),
                        Sequence::new(vec![
                            Ref::new("BracketedColumnReferenceListGrammar").to_matchable(),
                            Ref::new("SelectableGrammar").to_matchable(),
                        ])
                        .to_matchable(),
                        Ref::new("DefaultValuesGrammar").to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "SetSessionStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::SetSessionStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("SET").to_matchable(),
                    Ref::keyword("SESSION").to_matchable(),
                    Sequence::new(vec![
                        Ref::new("ParameterNameSegment").to_matchable(),
                        Ref::new("DotSegment").to_matchable(),
                    ])
                    .config(|this| {
                        this.optional();
                    })
                    .to_matchable(),
                    Ref::new("ParameterNameSegment").to_matchable(),
                    Ref::new("EqualsSegment").to_matchable(),
                    Ref::new("ExpressionSegment").to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "AlterTableStatementSegment".into(),
            NodeMatcher::new(SyntaxKind::AlterTableStatement, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("ALTER").to_matchable(),
                    Ref::keyword("TABLE").to_matchable(),
                    Ref::new("IfExistsGrammar").optional().to_matchable(),
                    Ref::new("TableReferenceSegment").to_matchable(),
                    one_of(vec![
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("TableReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ADD").to_matchable(),
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("IfNotExistsGrammar").optional().to_matchable(),
                            Ref::new("ColumnDefinitionSegment").to_matchable(),
                            one_of(vec![
                                Ref::keyword("FIRST").to_matchable(),
                                Ref::keyword("LAST").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("AFTER").to_matchable(),
                                    Ref::new("ColumnReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("DROP").to_matchable(),
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("IfExistsGrammar").optional().to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("RENAME").to_matchable(),
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("IfExistsGrammar").optional().to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            Ref::keyword("TO").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("ALTER").to_matchable(),
                            Ref::keyword("COLUMN").to_matchable(),
                            Ref::new("ColumnReferenceSegment").to_matchable(),
                            one_of(vec![
                                Sequence::new(vec![
                                    Ref::keyword("SET").to_matchable(),
                                    Ref::keyword("DATA").to_matchable(),
                                    Ref::keyword("TYPE").to_matchable(),
                                    Ref::new("DatatypeSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("DROP").to_matchable(),
                                    Ref::keyword("NOT").to_matchable(),
                                    Ref::keyword("NULL").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::keyword("AUTHORIZATION").to_matchable(),
                            one_of(vec![
                                Ref::new("RoleReferenceSegment").to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("USER").to_matchable(),
                                    Ref::new("RoleReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                                Sequence::new(vec![
                                    Ref::keyword("ROLE").to_matchable(),
                                    Ref::new("RoleReferenceSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("SET").to_matchable(),
                            Ref::keyword("PROPERTIES").to_matchable(),
                            Delimited::new(vec![
                                Sequence::new(vec![
                                    Ref::new("ParameterNameSegment").to_matchable(),
                                    Ref::new("EqualsSegment").to_matchable(),
                                    Ref::new("ExpressionSegment").to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .to_matchable(),
                        ])
                        .to_matchable(),
                        Sequence::new(vec![
                            Ref::keyword("EXECUTE").to_matchable(),
                            Ref::new("FunctionNameSegment").to_matchable(),
                            Bracketed::new(vec![
                                Delimited::new(vec![
                                    Sequence::new(vec![
                                        Ref::new("ParameterNameSegment").to_matchable(),
                                        Ref::new("ExecuteArrowSegment").to_matchable(),
                                        Ref::new("ExpressionSegment").to_matchable(),
                                    ])
                                    .to_matchable(),
                                ])
                                .to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                            Sequence::new(vec![
                                Ref::keyword("WHERE").to_matchable(),
                                Ref::new("ExpressionSegment").to_matchable(),
                            ])
                            .config(|this| {
                                this.optional();
                            })
                            .to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MapTypeSegment".into(),
            NodeMatcher::new(SyntaxKind::MapType, |_dialect| {
                Sequence::new(vec![
                    Ref::keyword("MAP").to_matchable(),
                    Ref::new("MapTypeSchemaSegment").optional().to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
        (
            "MapTypeSchemaSegment".into(),
            NodeMatcher::new(SyntaxKind::MapTypeSchema, |_dialect| {
                one_of(vec![
                    Bracketed::new(vec![
                        Sequence::new(vec![
                            Ref::new("PrimitiveTypeSegment").to_matchable(),
                            Ref::new("CommaSegment").to_matchable(),
                            Ref::new("DatatypeSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.bracket_type("angle");
                        this.bracket_pairs_set = "angle_bracket_pairs";
                    })
                    .to_matchable(),
                    Bracketed::new(vec![
                        Sequence::new(vec![
                            Ref::new("PrimitiveTypeSegment").to_matchable(),
                            Ref::new("CommaSegment").to_matchable(),
                            Ref::new("DatatypeSegment").to_matchable(),
                        ])
                        .to_matchable(),
                    ])
                    .config(|this| {
                        this.bracket_type("round");
                        this.bracket_pairs_set = "bracket_pairs";
                    })
                    .to_matchable(),
                ])
                .to_matchable()
            })
            .to_matchable()
            .into(),
        ),
    ]);

    trino_dialect
}
